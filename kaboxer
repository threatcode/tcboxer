#! /usr/bin/python3

import argparse
import yaml
import os
import sys
import re
import grp
import subprocess
import shlex
import shutil
import io
import tarfile
import glob
import docker
import dockerpty
import jinja2
import prompt_toolkit
import tempfile
import pathlib
import packaging.version as packaging_version
import logging
import requests
import json

class Kaboxer:
    def __init__(self):
        self.parser = argparse.ArgumentParser()
        self.parser.add_argument('--verbose', '-v', action='count', default=0, help='increase verbosity')

        subparsers = self.parser.add_subparsers(title='subcommands', help='action to perform', dest='action', required=True)

        parser_run = subparsers.add_parser('run', help='run containerized app')
        parser_run.add_argument('app')
        parser_run.add_argument("--component", help='component to run')
        parser_run.add_argument("--reuse-container", action="store_true", help='run in existing container')
        parser_run.add_argument("--detach", help='run in the background', action="store_true")
        parser_run.add_argument("--prompt-before-detach", help='message to display before detaching')
        parser_run.add_argument("--version", help='version to run')
        parser_run.add_argument('executable', nargs='*')
        parser_run.set_defaults(func=self.cmd_run)

        parser_stop = subparsers.add_parser('stop', help='stop running containerized app')
        parser_stop.add_argument('app')
        parser_stop.set_defaults(func=self.cmd_stop)

        parser_get_meta_file = subparsers.add_parser('get-meta-file', help='get installed get_meta_file of containerized app')
        parser_get_meta_file.add_argument('app')
        parser_get_meta_file.add_argument('file')
        parser_get_meta_file.set_defaults(func=self.cmd_get_meta_file)

        parser_prepare = subparsers.add_parser('prepare', help='prepare container(s)')
        parser_prepare.add_argument('app', nargs='+')
        parser_prepare.set_defaults(func=self.cmd_prepare)

        parser_upgrade = subparsers.add_parser('upgrade', help='upgrade container(s)')
        parser_upgrade.add_argument('app', nargs='+')
        parser_upgrade.set_defaults(func=self.cmd_upgrade)

        parser_list = subparsers.add_parser('list', help='list containers')
        parser_list.add_argument("--installed", action="store_true", help='list installed containers')
        parser_list.add_argument("--available", action="store_true", help='list available containers')
        parser_list.add_argument("--upgradeable", action="store_true", help='list upgradeable containers')
        parser_list.add_argument("--all", action="store_true", help='list all versions of containers')
        parser_list.set_defaults(func=self.cmd_list)

        parser_build = subparsers.add_parser('build', help='build image')
        parser_build.add_argument("--save", action="store_true", help='save container image after build')
        parser_build.add_argument("--push", action="store_true", help='push container image to registry after build')
        parser_build.add_argument("--version", help='app version')
        parser_build.add_argument("--ignore-version", action="store_true", help='ignore version checks')
        parser_build.add_argument('app', nargs='?')
        parser_build.add_argument('path', nargs='?')
        parser_build.set_defaults(func=self.cmd_build)

        parser_install = subparsers.add_parser('install', help='install image')
        parser_install.add_argument("--tarball", action="store_true", help='install tarball')
        parser_install.add_argument("--destdir", help='build-time destination dir', default='')
        parser_install.add_argument("--prefix", help='prefix for the installation path', default='/usr/local')
        parser_install.add_argument('app', nargs='?')
        parser_install.add_argument('path', nargs='?')
        parser_install.set_defaults(func=self.cmd_install)

        parser_clean = subparsers.add_parser('clean', help='clean directory')
        parser_clean.add_argument('app', nargs='?')
        parser_clean.add_argument('path', nargs='?')
        parser_clean.set_defaults(func=self.cmd_clean)

        parser_pull = subparsers.add_parser('pull', help='fetch image')
        parser_pull.add_argument('app')
        parser_pull.set_defaults(func=self.cmd_pull)

        parser_push = subparsers.add_parser('push', help='push image to registry')
        parser_push.add_argument('app')
        parser_push.set_defaults(func=self.cmd_push)

        parser_save = subparsers.add_parser('save', help='save image')
        parser_save.add_argument('app')
        parser_save.add_argument('file')
        parser_save.set_defaults(func=self.cmd_save)

        parser_load = subparsers.add_parser('load', help='load image')
        parser_load.add_argument('app')
        parser_load.add_argument('file')
        parser_load.set_defaults(func=self.cmd_load)

        parser_purge = subparsers.add_parser('purge', help='purge image')
        parser_purge.add_argument('app')
        parser_purge.add_argument("--prune", action="store_true", help='prune unused images')
        parser_purge.set_defaults(func=self.cmd_purge)

        self.args = self.parser.parse_args()

        loglevels = { 0: 'ERROR',
                      1: 'INFO',
                      2: 'DEBUG',
        }
        try:
            ll = loglevels[self.args.verbose]
        except KeyError:
            ll = 'DEBUG'
        ll = getattr(logging,ll)
        self.logger = logging.Logger('kbxbuilder')
        self.logger.setLevel(ll)
        ch = logging.StreamHandler()
        self.logger.addHandler(ch)

        try:
            self.docker_conn = docker.from_env()
            self.docker_conn.containers.list()
        except:
            groups = list(map(lambda g: grp.getgrgid(g)[0], os.getgroups()))
            if 'docker' in groups:
                self.logger.error ("No access to Docker even though you're a member of the docker group, is docker.service running?")
                sys.exit(1)
            else:
                if 'kaboxer' in groups:
                    nc = ['sudo', '-g', 'docker'] + sys.argv
                    sys.stdout.flush()
                    sys.stderr.flush()
                    os.execv('/usr/bin/sudo', nc)
                else:
                    self.logger.error ("No access to Docker, are you a member of group docker or kaboxer?")
                    sys.exit(1)

        self.config_paths = [
            '.',
            '/etc/kaboxer',
            '/usr/local/share/kaboxer',
            '/usr/share/kaboxer',
        ]

    def go(self):
        self.args.func()

    def cmd_run(self):
        app = self.args.app
        if self.args.version:
            self.prepare_or_upgrade(["%s=%s" % (app, self.args.version)])
            tag_name = self.args.version
        else:
            self.prepare_or_upgrade([app])
            installed_apps, _, _ = self.list_apps()
            tag_name = installed_apps[app]
        self.read_config(app)
        image_name = self.get_image_name(app)
        image = '%s:%s'%(image_name,tag_name)

        if self.args.reuse_container:
            containers = self.docker_conn.containers.list(filters={'name': app})
            container = containers[0]

        run_mode = self.component_config['run_mode']
        try:
            opts = self.component_config['docker_options']
        except:
            opts = {}
        if self.args.detach:
            if self.component_config['run_mode'] == 'headless':
                opts['detach'] = True
            else:
                self.logger.error ("Can't detach a non-headless component")
                sys.exit(1)

        opts = self.parse_component_config(opts)
        extranets = []
        try:
            netname = self.component_config['networks'][0]
            self.create_network(netname)
            opts['network'] = netname
            extranets = self.component_config['networks'][1:]
        except KeyError:
            pass

        if not self.component_config['run_as_root'] and not self.args.reuse_container:
            opts2 = opts.copy()
            opts2['detach'] = False
            opts2['tty'] = True
            precmds = [
                [ 'addgroup', '--debug', '--gid', str(self.gid), self.gname ],
                [ 'adduser', '--debug', '--uid', str(self.uid), '--gid', str(self.gid), '--home', self.home_in, '--gecos', self.gecos, '--disabled-password', self.uname ],
            ]
            container = self.docker_conn.containers.create(image, **opts2)
            opts['entrypoint'] = container.attrs['Config']['Entrypoint']
            container.remove()
            try:
                del (opts2['command'])
            except KeyError:
                pass
            for precmd in precmds:
                opts2['entrypoint'] = precmd
                container = self.docker_conn.containers.create(image, **opts2)
                container.start()
                container.wait()
                image = container.commit()
                container.remove()
            opts['user'] = self.uid
            opts['environment']['HOME'] = self.home_in

        if run_mode == 'cli':
            opts['tty'] = True
            opts['stdin_open'] = True
        elif run_mode == 'gui':
            self.create_xauth()
            opts['environment']['DISPLAY'] = os.getenv('DISPLAY')
            opts['environment']['XAUTHORITY'] = self.xauth_in
            opts['mounts'].append(docker.types.Mount(self.xauth_in,self.xauth_out,type='bind'))
        elif run_mode == 'headless':
            opts['name'] = self.args.app
        else:
            self.logger.error ("Unknown run mode")
            sys.exit(1)
        if run_mode == 'gui' or ('allow_x11' in self.component_config and self.component_config['allow_x11']):
            xsock = '/tmp/.X11-unix'
            opts['mounts'].append(docker.types.Mount(xsock,xsock,type='bind'))

        executable = self.args.executable
        if not len(executable) and 'executable' in self.component_config:
            executable = self.component_config['executable']
        if not isinstance(executable,list):
            executable = shlex.split(executable)
        try:
            executable.extend(shlex.split(self.component_config['extra_opts']))
        except KeyError:
            pass
        try:
            opts['entrypoint'] = ''
        except KeyError:
            pass

        if self.args.reuse_container:
            if run_mode == 'gui':
                self.create_xauth()
                bio = io.BytesIO()
                tf = tarfile.open(mode='w:',fileobj=bio)
                ti = tarfile.TarInfo()
                ti.name = self.xauth_in
                def tifilter(x):
                    if not self.component_config['run_as_root']:
                        x.uid = self.uid
                        x.gid = self.gid
                        x.uname = self.uname
                        x.gname = self.gname
                    return x
                tf.add(self.xauth_out, arcname=self.xauth_in, filter=tifilter)
                tf.close()
                container.put_archive('/', bio.getvalue())
            ex_with_env = ['env']
            for e in opts['environment']:
                ex_with_env.append("%s=%s" % (e, shlex.quote(opts['environment'][e])))
            ex_with_env.extend(executable)
            executable = ex_with_env
            dockerpty.exec_command(self.docker_conn.api, container.id, executable)
        else:
            opts['auto_remove'] = True
            container = self.docker_conn.containers.create(image, executable, **opts)
            for e in extranets:
                create_network(e).connect(container)
            dockerpty.start(self.docker_conn.api,container.id)
            if self.args.detach and self.args.prompt_before_detach:
                c = prompt_toolkit.prompt(self.args.prompt_before_detach)

    def cmd_stop(self):
        self.read_config(self.args.app)
        run_mode = self.component_config['run_mode']
        image = 'kaboxer/'+self.args.app
        if run_mode == 'headless':
            containers = self.docker_conn.containers.list(filters={'name': self.args.app})
            container = containers[0]
            container.stop()
        else:
            self.logger.error ("Can't stop a non-headless component")
            sys.exit(1)

    def get_meta_file(self, image, filename):
        with tempfile.NamedTemporaryFile(mode='w+t',prefix="getmetafile") as tmp:
            self.extract_file_from_image(image,os.path.join('/kaboxer/',filename),tmp.name)
            v = str(open(tmp.name).read())
            return v

    def cmd_get_meta_file(self):
        self.read_config(self.args.app)
        image = 'kaboxer/'+self.args.app
        print(self.get_meta_file(image,self.args.file))

    def find_config_for_build_apps(self):
        try:
            if self.args.path is None:
                path = os.getcwd()
            else:
                path = self.args.path
        except:
            path = os.getcwd()
        yamlfiles = []
        globs = [ 'kaboxer.yaml', '*.kaboxer.yaml' ]
        parsed_configs = {}
        for g in globs:
            for f in glob.glob(os.path.join(path,g)):
                yamlfiles.append(f)
        for f in yamlfiles:
            y = yaml.safe_load(open(f))
            try:
                app = y['application']['id']
                if self.args.app and self.args.app != app:
                    continue
                if app in parsed_configs:
                    continue
                parsed_configs[app] = y
                parsed_configs[app]['_config_file'] = f
            except:
                pass
        if not parsed_configs:
            self.logger.error("Failed to find appropriate kaboxer.yaml file")
            sys.exit(1)
        return parsed_configs

    def do_version_checks(self,v,config):
        parsed_v = packaging_version.parse(v)
        try:
            minv = str(config['packaging']['min_upstream_version'])
            parsed_minv = packaging_version.parse(minv)
            if parsed_v < parsed_minv:
                raise Exception("Unsupported upstream version %s < %s" % (v, minv))
        except KeyError:
            pass
        try:
            maxv = str(config['packaging']['max_upstream_version'])
            parsed_maxv = packaging_version.parse(maxv)
            if parsed_v > parsed_maxv:
                raise Exception("Unsupported upstream version %s > %s" % (v, maxv))
        except KeyError:
            pass

    def cmd_build(self):
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        parsed_configs = self.find_config_for_build_apps()
        for app in parsed_configs:
            self.logger.info("Building %s" % (app,))
            parsed_config = parsed_configs[app]
            try:
                df = os.path.join(path,parsed_config['build']['docker']['file'])
            except:
                df = os.path.join(path,'Dockerfile')
            buildargs = {}
            if self.args.version:
                if not self.args.ignore_version:
                    try:
                        self.do_version_checks(self.args.version,parsed_config)
                    except Exception as e:
                        self.logger.error(str(e))
                        sys.exit(1)
                buildargs['KBX_APP_VERSION'] = self.args.version
            (image, _) = self.docker_conn.images.build(
                path=path, dockerfile=df, rm=True, forcerm=True, nocache=True,
                pull=True, quiet=False, buildargs=buildargs)
            with tempfile.NamedTemporaryFile(mode='w+t') as tmp:
                try:
                    self.extract_file_from_image(image,'/kaboxer/version',tmp.name)
                    saved_version = open(tmp.name).readline().strip()
                    if not self.args.ignore_version:
                        try:
                            self.do_version_checks(saved_version,parsed_config)
                        except Exception as e:
                            self.docker_conn.images.remove(image=image.id)
                            self.logger.error(str(e))
                            sys.exit(1)
                except Exception as e:
                    if self.args.version:
                        saved_version = self.args.version
                        tmp.write(self.args.version)
                    else:
                        self.logger.error("Unable to determine version (use --version?)")
                        self.docker_conn.images.remove(image=image.id)
                        sys.exit(1)
                tmp.flush()
                image = self.inject_file_into_image(image,tmp.name,'/kaboxer/version')
            with tempfile.NamedTemporaryFile(mode='w+t') as tmp:
                tmp.write(str(parsed_config['packaging']['revision'])+"\n")
                tmp.flush()
                image = self.inject_file_into_image(image,tmp.name,'/kaboxer/packaging-revision')
            with tempfile.NamedTemporaryFile(mode='w+t') as tmp:
                tmp.write(yaml.dump(sys.argv))
                tmp.flush()
                image = self.inject_file_into_image(image,tmp.name,'/kaboxer/kaboxer-build-cmd')
                image = self.inject_file_into_image(image,df,'/kaboxer/Dockerfile')
            with tempfile.NamedTemporaryFile(mode='w+t') as tmp:
                savedbuildargs = {
                    'rm': True,
                    'forcerm': True,
                    'path': path,
                    'dockerfile': df,
                    'buildargs': buildargs
                }
                tmp.write(yaml.dump(savedbuildargs))
                tmp.flush()
                image = self.inject_file_into_image(image,tmp.name,'/kaboxer/docker-build-parameters')
                tagname='kaboxer/%s:latest'%(app,)
                image.tag(tagname)
                tagname='kaboxer/%s:%s'%(app,str(saved_version))
                image.tag(tagname)
            if self.args.save:
                tarball = os.path.join(path,parsed_config['application']['id']+'.tar')
                self.save_image_to_file(image,tarball)
            if self.args.push:
                self.cmd_push()
            try:
                parsed_config['install']['desktop-files']
            except:
                self.gen_desktop_files(parsed_config)

    def cmd_push(self):
        parsed_configs = self.find_config_for_build_apps()
        for app in parsed_configs:
            self.logger.info("Pushing %s" % (app,))
            parsed_config = parsed_configs[app]
            if 'registry' not in parsed_config['container']['origin']:
                self.logger.error ("No registry defined for %s"%(app,))
                sys.exit(1)
            registry = parsed_config['container']['origin']['registry']['url']
            registry = re.sub('^https?://','',registry)
            try:
                imagename = parsed_config['container']['origin']['registry']['image']
            except KeyError:
                imagename = parsed_config['application']['id']
            tagname = "kaboxer/%s:latest"%(imagename,)
            image = self.find_image(tagname)
            if not image:
                self.logger.error("No %s image found"%(tagname,))
                sys.exit(1)
            with tempfile.NamedTemporaryFile(mode='w+t') as tmp:
                self.extract_file_from_image(image.id,'/kaboxer/version',tmp.name)
                saved_version = open(tmp.name).readline().strip()
            remotename = '%s/%s' % (registry, imagename)
            tagname='%s:latest'%(remotename,)
            image.tag(tagname)
            tagname='%s:%s'%(remotename,str(saved_version))
            image.tag(tagname)
            self.docker_conn.images.push(remotename)

    def gen_desktop_files(self, parsed_config):
        template_text = """[Desktop Entry]
Name={{ p.name }}
Comment={{ p.comment }}
Exec={{ p.exec }}
Icon=kaboxer-{{ p.appid }}
Terminal={{ p.terminal }}
Type=Application
Categories={{ p.categories }}

"""
        t = jinja2.Template(template_text)
        for component in parsed_config['components']:
            params = {
                'comment': parsed_config['application']['description'],
                'component': component,
                'appid': parsed_config['application']['id'],
                'categories': parsed_config['application']['categories'],
            }
            params['reuse_container'] = ''
            try:
                if parsed_config['components'][component]['reuse_container']:
                    params['reuse_container'] = '--reuse-container '
            except:
                pass
            try:
                component_name = parsed_config['components'][component]['name']
            except:
                component_name = parsed_config['application']['name']
            if parsed_config['components'][component]['run_mode'] == 'headless':
                # One .desktop file for starting
                params['name'] = "Start %s" % (component_name,)
                params['terminal'] = 'true'
                try:
                    detach_message = parsed_config['components'][component]['start_message']
                except:
                    detach_message = "%s started" % (component_name,)
                params['exec'] = "kaboxer run --detach --prompt_before_detach %s%s--component %s %s" % (shlex.quote(detach_message), params['reuse_container'], params['component'], params['appid'])
                ofname = 'kaboxer-%s-%s-start.desktop' % (parsed_config['application']['id'], component)
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))
                # One .desktop file for stopping
                params['name'] = "Stop %s" % (component_name,)
                params['terminal'] = 'false'
                params['exec'] = "kaboxer stop %s--component %s %s" % (params['reuse_container'], params['component'], params['appid'])
                ofname = 'kaboxer-%s-%s-stop.desktop' % (parsed_config['application']['id'], component)
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))
            else:
                params['name'] = component_name
                ofname = 'kaboxer-%s-%s.desktop' % (parsed_config['application']['id'], component)
                params['exec'] = "kaboxer run %s--component %s %s" % (params['reuse_container'], params['component'], params['appid'])
                if parsed_config['components'][component]['run_mode'] == 'cli':
                    params['terminal'] = 'true'
                else:
                    params['terminal'] = 'false'
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))

    def cmd_clean(self):
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        path = os.path.realpath(path)
        parsed_configs = self.find_config_for_build_apps()
        for app in parsed_configs:
            self.logger.info("Cleaning %s" % (app,))
            parsed_config = parsed_configs[app]
            app = parsed_config['application']['id']
            tarball = os.path.join(path,parsed_config['application']['id']+'.tar')
            if os.path.commonpath([path,tarball]) == path and os.path.isfile(tarball):
                os.unlink(tarball)
            generateddesktopfiles = self._list_desktop_files(parsed_config,generated_only=True)
            for d in generateddesktopfiles:
                if os.path.isfile(d):
                    os.unlink(d)

    def install_to_path(self,f,path):
        if self.args.destdir == '':
            builddestpath = path
        else:
            builddestpath = os.path.join(self.args.destdir, os.path.relpath(path,'/'))
        self.logger.info("Installing %s to %s" % (f,builddestpath))
        os.makedirs(builddestpath, exist_ok=True)
        shutil.copy(f,builddestpath)

    def _list_desktop_files(self,parsed_config,generated_only=False):
        try:
            desktopfiles = parsed_config['install']['desktop-files']
            if generated_only:
                return []
        except:
            desktopfiles = []
            for component in parsed_config['components']:
                if parsed_config['components'][component]['run_mode'] == 'headless':
                    desktopfiles.append('kaboxer-%s-%s-start.desktop' % (parsed_config['application']['id'], component))
                    desktopfiles.append('kaboxer-%s-%s-stop.desktop' % (parsed_config['application']['id'], component))
                else:
                    desktopfiles.append('kaboxer-%s-%s.desktop' % (parsed_config['application']['id'], component))
        return desktopfiles

    def cmd_install(self):
        main_destpath = os.path.join(self.args.prefix, 'share', 'kaboxer')
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        parsed_configs = self.find_config_for_build_apps()
        for app in parsed_configs:
            self.logger.info("Installing %s" % (app,))
            parsed_config = parsed_configs[app]
            # Install image tarball
            if self.args.tarball:
                tarball = os.path.join(path,app+'.tar')
                try:
                    self.install_to_path(tarball, main_destpath)
                except shutil.SameFileError:
                    pass
            # Install kaboxer.yaml file
            # Update it first if we ship the tarball
            with tempfile.TemporaryDirectory() as td:
                filtered_config_file = parsed_config.copy()
                del(filtered_config_file['_config_file'])
                tf = os.path.join(td,app+'.kaboxer.yaml')
                if self.args.tarball:
                    try:
                        del(filtered_config_file['container']['origin']['registry'])
                    except:
                        pass
                    if 'origin' not in filtered_config_file['container']:
                        filtered_config_file['container']['origin'] = {}
                    filtered_config_file['container']['origin']['tarball'] = os.path.join(main_destpath,app+'.tar')
                self.logger.info(filtered_config_file)
                with open(tf,'w') as y:
                    y.write(yaml.dump(filtered_config_file))
                self.install_to_path(tf, main_destpath)
            # Install desktop file(s)
            desktopfiles = self._list_desktop_files(parsed_config)
            for d in desktopfiles:
                self.install_to_path(os.path.join(path,d),os.path.join(self.args.prefix, 'share', 'applications'))
            # Install icon file(s)
            try:
                iconfile = parsed_config['install']['icon']
                (_,ife) = os.path.splitext(os.path.basename(iconfile))
                with tempfile.TemporaryDirectory() as td:
                    renamed_icon = os.path.join(td, 'kaboxer-%s%s' % (parsed_config['application']['id'], ife))
                    shutil.copy(iconfile,renamed_icon)
                    self.install_to_path(renamed_icon,os.path.join(self.args.prefix, 'share', 'icons'))
            except KeyError:
                pass
            try:
                iconfile = parsed_config['install']['extract-icon']
                (_,ife) = os.path.splitext(os.path.basename(iconfile))
                with tempfile.TemporaryDirectory() as td:
                    renamed_icon = os.path.join(td, 'kaboxer-%s%s' % (parsed_config['application']['id'], ife))
                    self.extract_file_from_image('kaboxer/'+parsed_config['application']['id'],iconfile,renamed_icon)
                    self.install_to_path(renamed_icon,os.path.join(self.args.prefix, 'share', 'icons'))
            except KeyError:
                pass

    def extract_file_from_image(self,image,infile,outfile):
        temp_container = self.docker_conn.containers.create(image)
        (bits, stat) = temp_container.get_archive(infile)
        with tempfile.TemporaryFile() as temptar:
            for chunk in bits:
                temptar.write(chunk)
            temptar.seek(0)
            tf = tarfile.open(fileobj=temptar)
            ti = tf.getmembers()[0]
            with tempfile.TemporaryDirectory() as td:
                tf.extract(ti,path=td,set_attrs=False)
                shutil.move(os.path.join(td,ti.name), outfile)
        temp_container.remove()

    def extract_file_from_tarball(self,tarball,infile,outfile):
        tf = tarfile.open(tarball)
        manifest = tf.extractfile('manifest.json')
        j = json.loads(manifest.read())
        relpath = os.path.relpath(infile, '/')
        for layer in j[0]['Layers']:
            tfl = tarfile.open(fileobj=tf.extractfile(layer))
            try:
                with tempfile.TemporaryDirectory() as td:
                    tfl.extract(relpath,path=td)
                    shutil.move(os.path.join(td,relpath), outfile)
                    return 1
            except:
                continue
        raise Exception('Not found')

    def get_meta_file_from_tarball(self, tarball, filename):
        with tempfile.NamedTemporaryFile(mode='w+t',prefix="getmetafile") as tmp:
            self.extract_file_from_tarball(tarball,os.path.join('/kaboxer/',filename),tmp.name)
            v = str(open(tmp.name).read())
            return v

    def inject_file_into_image(self,image,outfile,infile):
        temp_container = self.docker_conn.containers.create(image)
        with tempfile.TemporaryFile() as temptar:
            tf = tarfile.open(fileobj=temptar,mode='w')
            (dirname,filename) = os.path.split(infile)
            p = pathlib.Path(dirname)
            for parent in reversed(p.parents):
                ti = tarfile.TarInfo(name=str(parent))
                ti.type = tarfile.DIRTYPE
                tf.addfile(ti)
            ti = tarfile.TarInfo(name=infile)
            ti.size = os.stat(outfile).st_size
            tf.addfile(ti, fileobj=open(outfile,mode='rb'))
            tf.close()
            temptar.seek(0)
            buf = b''
            while True:
                b = temptar.read()
                if not b:
                    break
                buf += b
            temp_container.put_archive('/',buf)
        image = temp_container.commit()
        temp_container.remove()
        return image

    def cmd_save(self):
        images = self.docker_conn.images.list()
        for image in images:
            for tag in image.tags:
                if tag == 'kaboxer/'+self.args.app + ':latest':
                    self.save_image_to_file(image,self.args.file)
                    return
        self.logger.error("No image found")
        sys.exit(1)

    def save_image_to_file(self,image,destfile):
        with open(destfile, 'wb') as f:
            for chunk in image.save():
                f.write(chunk)

    def load_image(self, tarfile, appname, tag):
        f = open(tarfile, 'rb')
        for image in self.docker_conn.images.load(f):
            image.tag('kaboxer/'+appname, tag=tag)

    def cmd_load(self):
        v = self.get_meta_file_from_tarball(self.args.file, 'version').strip()
        self.logger.info("Loading %s at version %s" % (self.args.app, v))
        self.load_image(self.args.file, self.args.app, v)

    def find_image(self, name):
        images = self.docker_conn.images.list()
        candidates = {}
        for image in images:
            for tag in image.tags:
                if tag == name:
                    return image
                if tag[:len(name)] == name and tag[len(name)] == ':':
                    ver = tag[len(name)+1:]
                    candidates[tag] = { 'image': image,
                                        'version': packaging_version.parse(ver) }
        if len(candidates):
            versions = [ candidates[x]['version'] for x in candidates.keys() ]
            maxver = sorted(versions)[-1]
            for c in candidates:
                if candidates[c]['version'] == maxver:
                    return candidates[c]['image']
        return False

    def get_image_name(self,app,config=None):
        if config is None:
            config = self.load_config(app)
        try:
            if 'registry' in config['container']['origin']:
                registry = config['container']['origin']['registry']['url']
                registry = re.sub('^https?://','',registry)
                try:
                    image = config['container']['origin']['registry']['image']
                except KeyError:
                    image = config['application']['id']
                return "%s/%s" % (registry, image)
        except KeyError:
            pass
        return "kaboxer/%s" % (config['application']['id'],)

    def cmd_prepare(self):
        self.prepare_or_upgrade(self.args.app)

    def cmd_upgrade(self):
        self.prepare_or_upgrade(self.args.app, upgrade=True)

    def do_upgrade_scripts(self, app, oldver, newver):
        self.read_config(app)
        if oldver is None or oldver == newver:
            return
        self.logger.info("Running upgrade scripts for %s (%s -> %s)" % (app,oldver,newver))
        image_name = self.get_image_name(app)
        with tempfile.TemporaryDirectory() as td:
            s = td
            t = '/kaboxer/upgrade-data'
            opts = { 'mounts': [docker.types.Mount(t,s,type='bind')] }
            opts = self.parse_component_config(opts)
            full_image_name = '%s:%s'%(image_name,oldver)
            container = self.docker_conn.containers.create(full_image_name, ['/kaboxer/scripts/pre-upgrade'], **opts)
            dockerpty.start(self.docker_conn.api, container.id)
            container.stop()
            container.remove()
            full_image_name = '%s:%s'%(image_name,newver)
            container = self.docker_conn.containers.create(full_image_name, ['/kaboxer/scripts/post-upgrade', oldver], **opts)
            dockerpty.start(self.docker_conn.api, container.id)
            container.stop()
            container.remove()

    def prepare_or_upgrade(self, apps, upgrade=False):
        installed_apps, registry_apps, tarball_apps = self.list_apps(get_remotes=True, restrict=apps)
        for app in apps:
            self.logger.info("Preparing %s" % (app,))
            previous_version = None
            m = re.search('([^=]+)=([^=]+)$', app)
            if m:
                app = m.group(1)
                target_version = m.group(2)
                if app in installed_apps:
                    previous_version = installed_apps[app]
            else:
                if app in installed_apps:
                    previous_version = installed_apps[app]
                    if upgrade:
                        try:
                            target_version = registry_apps[app]['maxversion']
                        except KeyError:
                            target_version = tarball_apps[app]['version']
                    else:
                        target_version = previous_version
                else:
                    try:
                        target_version = registry_apps[app]['maxversion']
                    except KeyError:
                        target_version = tarball_apps[app]['version']
                self.read_config(app)
            if previous_version \
               and upgrade \
               and packaging_version.parse(target_version) <= packaging_version.parse(previous_version):
                target_version = previous_version
            image_name = self.get_image_name(app)
            full_image_name = '%s:%s'%(image_name,target_version)
            if self.find_image(full_image_name):
                return
            config = self.load_config(app)
            try:
                if 'registry' in config['container']['origin']:
                    if not self.find_image(full_image_name):
                        self.logger.info("Pulling %s image from registry"%(full_image_name,))
                        try:
                            image = self.docker_conn.images.pull(full_image_name)
                        except docker.errors.APIError:
                            self.logger.error("Could not pull image from registry, wrong URL?")
                            sys.exit(1)
                        self.do_upgrade_scripts(app, previous_version, target_version)
                    return
                if 'tarball' in config['container']['origin']:
                    paths = [
                        '.',
                        '/usr/local/share/kaboxer',
                        '/usr/share/kaboxer',
                    ]
                    for p in paths:
                        tarfile = os.path.join(p,config['container']['origin']['tarball'])
                        if os.path.isfile(tarfile):
                            self.logger.info("Loading image from "+tarfile)
                            self.load_image(tarfile, app, target_version)
                        self.do_upgrade_scripts(app, previous_version, target_version)
                        return
            except KeyError:
                pass
            if not self.find_image(full_image_name):
                paths = [
                    '.',
                    '/usr/local/share/kaboxer',
                    '/usr/share/kaboxer',
                ]
                for p in paths:
                    tarfile = os.path.join(p,self.config['application']['id']+'.tar')
                    if os.path.isfile(tarfile):
                        self.logger.info("Loading image from "+tarfile)
                        self.load_image(tarfile, app, target_version)
                        self.do_upgrade_scripts(app, previous_version, target_version)
                        return
            self.logger.error("Cannot prepare image")
            sys.exit(1)

    def cmd_pull(self):
        self.cmd_build()

    def cmd_purge(self):
        installed_apps, _, _ = self.list_apps()
        if self.args.app in installed_apps:
            self.docker_conn.images.remove('kaboxer/%s:%s'%(self.args.app,installed_apps[self.args.app]))
            try:
                self.docker_conn.images.remove('kaboxer/%s'%(self.args.app,))
            except:
                pass
            if self.args.prune:
                self.docker_conn.images.prune(filters={'dangling': True})

    def list_apps(self, get_remotes=False, restrict=None):
        installed_apps = {}
        registry_apps = {}
        tarball_apps = {}

        if restrict is not None:
            restrict = [ re.sub('=.*', '', i) for i in restrict ]

        yamlfiles = []
        globs = [ 'kaboxer.yaml', '*.kaboxer.yaml' ]
        for p in self.config_paths:
            for g in globs:
                for f in glob.glob(os.path.join(p,g)):
                    try:
                        y = yaml.safe_load(open(f))
                        aid = y['application']['id']
                        if restrict is not None and aid not in restrict:
                            continue
                        try:
                            appconfig = self.load_config(aid)
                            imagename = self.get_image_name(aid)
                            image = self.find_image(imagename)
                            installed_apps[aid] = self.get_meta_file(image,'version').strip()
                        except Exception as e:
                            pass
                        try:
                            registry_apps[aid] = { 'url': y['container']['origin']['registry']['url'],
                                                   'image': y['container']['origin']['registry']['image'], }
                        except:
                            pass
                        try:
                            tb = y['container']['origin']['tarball']
                            tarball_apps[aid] = { 'tarball': tb,
                                                  'version': self.get_meta_file_from_tarball(tb,'version').strip(), }
                        except:
                            pass
                    except:
                        pass

        if get_remotes:
            registries = set()
            for aid in registry_apps:
                registries.add(registry_apps[aid]['url'])
            for url in registries:
                uurl = url
                if not re.match('https?://',uurl):
                    uurl = 'http://'+uurl
                try:
                    req = requests.get(uurl+"/v2/_catalog")
                    repos = req.json()['repositories']
                except:
                    for aid in registry_apps:
                        if url == registry_apps[aid]['url']:
                            registry_apps[aid]['versions'] = ['latest']
                            registry_apps[aid]['maxversion'] = 'latest'
                    continue
                for rep in repos:
                    if rep not in registry_apps:
                        continue
                    req2 = requests.get(uurl+"/v2/"+rep+"/tags/list")
                    registry_apps[rep]['versions'] = req2.json()['tags']
                    curmax = registry_apps[rep]['versions'][0]
                    for tag in registry_apps[aid]['versions']:
                        if tag == 'latest':
                            continue
                        if packaging_version.parse(tag) > packaging_version.parse(curmax):
                            curmax = tag
                    registry_apps[rep]['maxversion'] = curmax
        return (installed_apps, registry_apps, tarball_apps)

    def cmd_list(self):
        show_installed = self.args.installed
        show_available = self.args.available
        show_upgradeable = self.args.upgradeable
        if self.args.all:
            show_installed = True
            show_available = True
            show_upgradeable = True
        if not show_available and not show_upgradeable:
            show_installed = True
        installed_apps, registry_apps, tarball_apps = self.list_apps(get_remotes=(show_available or show_upgradeable))
        if show_installed:
            for aid in installed_apps:
                print("%s: %s [installed]" % (aid, installed_apps[aid]))

        if show_available:
            for aid in registry_apps:
                for tag in registry_apps[aid]['versions']:
                    if tag == 'latest':
                        continue
                    print("%s: %s [available]" % (aid, tag))

        if show_upgradeable:
            for aid in installed_apps:
                if aid in registry_apps:
                    if packaging_version.parse(registry_apps[aid]['maxversion']) > packaging_version.parse(installed_apps[aid]):
                        print("%s: %s [upgradeable from %s]" % (aid, registry_apps[aid]['maxversion'], installed_apps[aid]))
                elif aid in tarball_apps:
                    if packaging_version.parse(tarball_apps[aid]['version']) > packaging_version.parse(installed_apps[aid]):
                        print("%s: %s [upgradeable from %s]" % (aid, tarball_apps[aid]['version'], installed_apps[aid]))

    def load_config(self, app=None):
        for p in self.config_paths:
            for filename in [ app+'.kaboxer.yaml', 'kaboxer.yaml' ]:
                config_file = os.path.join(p,filename)
                if os.path.isfile(config_file):
                    try:
                        y = yaml.safe_load(open(config_file))
                        if y['application']['id'] == app:
                            return y
                    except:
                        pass
        self.logger.error("Could not find appropriate config file for "+app)
        sys.exit(1)

    def read_config(self, app):
        self.config = self.load_config(app)
        # If a component was specified
        try:
            component = self.args.component
            self.component_config = self.config['components'][component]
            return
        except:
            pass
        # If a default component is listed in the config file
        try:
            component = self.config['container']['default_component']
            self.component_config = self.config['components'][component]
            return
        except:
            pass
        # If there is a component called "default"
        try:
            self.component_config = self.config['components']['default']
            return
        except:
            pass
        # Otherwise take the first component
        try:
            components = sorted(self.config['components'].keys())
            component = components[0]
            self.component_config = self.config['components'][component]
            return
        except:
            pass

        self.logger.error("Can't find an appropriate component")
        sys.exit(1)

    def parse_component_config(self, opts):
        if 'environment' not in opts:
            opts['environment'] = {}
        if 'mounts' not in opts:
            opts['mounts'] = []
        try:
            ports = {}
            for publish_port in self.component_config['publish_ports']:
                ports[publish_port] = publish_port
            opts['ports'] = ports
        except KeyError:
            pass
        if 'run_as_root' not in self.component_config:
            self.component_config['run_as_root'] = False

        if self.component_config['run_as_root']:
            self.home_in = '/root'
        else:
            import pwd
            self.uid = os.getuid()
            self.uname = pwd.getpwuid(self.uid).pw_name
            self.gecos = pwd.getpwuid(self.uid).pw_gecos
            self.gid = pwd.getpwuid(self.uid).pw_gid
            self.gname = grp.getgrgid(self.gid).gr_name
            self.home_in = os.path.join('/home',self.uname)

        try:
            for mount in self.component_config['mounts']:
                s = mount['source']
                s = os.path.expanduser(s)
                try:
                    os.makedirs(s)
                except FileExistsError:
                    pass
                t = mount['target']
                if t == '~':
                    t = self.home_in
                else:
                    t = re.sub('^~/',self.home_in+'/',t)
                opts['mounts'].append(docker.types.Mount(t,s,type='bind'))
        except KeyError:
            pass

        return opts

    def create_network(self, netname):
        for n in self.docker_conn.networks.list():
            if n.name == netname:
                return n
        return self.docker_conn.networks.create(name=netname, driver='bridge')

    def create_xauth(self):
        if os.getenv('DISPLAY') is None:
            self.logger.error("No DISPLAY set, are you running in a graphical session?")
            sys.exit(1)
        self.xauth_out = os.path.join(os.getenv('HOME'), '.docker.xauth')
        self.xauth_in = os.path.join(self.home_in,'.docker.xauth')
        f = subprocess.Popen(['xauth', 'nlist', os.getenv('DISPLAY')], stdout=subprocess.PIPE).stdout
        g = subprocess.Popen(['xauth', '-f', self.xauth_out, 'nmerge', '-'], stdin=subprocess.PIPE).stdin
        for l in f:
            l = str(l,'utf-8')
            l.strip()
            ll = re.sub('^[^ ]*', 'ffff', l) + "\n"
            g.write(bytes(ll, 'utf-8'))
        g.close()
        f.close()

kaboxer = Kaboxer()
kaboxer.go()
