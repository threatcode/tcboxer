#! /usr/bin/python3

import argparse
import yaml
import os
import sys
import re
import grp
import subprocess
import shlex
import io
import tarfile

import docker
import dockerpty

class Kaboxer:
    def __init__(self):
        self.parser = argparse.ArgumentParser()

        subparsers = self.parser.add_subparsers(title='subcommands', help='action to perform', dest='action', required=True)

        parser_run = subparsers.add_parser('run', help='run containerized app')
        parser_run.add_argument('app')
        parser_run.add_argument("--component", help='component to run')
        parser_run.add_argument("--reuse-container", action="store_true", help='run in existing container')
        parser_run.add_argument("--detach", action="store_true")
        parser_run.add_argument('executable', nargs='*')
        parser_run.set_defaults(func=self.run)

        parser_stop = subparsers.add_parser('stop', help='stop running containerized app')
        parser_stop.add_argument('app')
        parser_stop.set_defaults(func=self.stop)

        parser_build = subparsers.add_parser('build', help='build image')
        parser_build.add_argument('app')
        parser_build.add_argument('path', nargs='?')
        parser_build.set_defaults(func=self.build)

        parser_pull = subparsers.add_parser('pull', help='fetch image')
        parser_pull.add_argument('app')
        parser_pull.set_defaults(func=self.pull)

        parser_pull = subparsers.add_parser('save', help='save image')
        parser_pull.add_argument('app')
        parser_pull.add_argument('file')
        parser_pull.set_defaults(func=self.save)

        parser_pull = subparsers.add_parser('load', help='load image')
        parser_pull.add_argument('app')
        parser_pull.add_argument('file')
        parser_pull.set_defaults(func=self.load)

        parser_purge = subparsers.add_parser('purge', help='purge image')
        parser_purge.add_argument('app')
        parser_purge.set_defaults(func=self.purge)

        try:
            self.docker_conn = docker.from_env()
            self.docker_conn.containers.list()
        except:
            groups = list(map(lambda g: grp.getgrgid(g)[0], os.getgroups()))
            if 'docker' in groups:
                print ("No access to Docker even though you're a member of the docker group, is docker.service running?")
                sys.exit(1)
            else:
                if 'kaboxer' in groups:
                    nc = ['sudo', '-g', 'docker'] + sys.argv
                    sys.stdout.flush()
                    sys.stderr.flush()
                    os.execv('/usr/bin/sudo', nc)
                else:
                    print ("No access to Docker, are you a member of group docker or kaboxer?")
                    sys.exit(1)

    def go(self):
        self.args = self.parser.parse_args()
        self.args.func()

    def run(self):
        self.read_config()

        if self.args.reuse_container:
            containers = self.docker_conn.containers.list(filters={'name': self.args.app})
            container = containers[0]

        run_mode = self.config['run_mode']
        try:
            opts = self.config['docker_options']
        except:
            opts = {}
        if self.args.detach:
            if self.config['run_mode'] == 'headless':
                opts['detach'] = True
            else:
                print ("Can't detach a non-headless component")
                sys.exit(1)
        opts['environment'] = {}
        opts['mounts'] = []
        extranets = []
        try:
            netname = self.config['networks'][0]
            self.create_network(netname)
            opts['network'] = netname
            extranets = self.config['networks'][1:]
        except KeyError:
            pass
        try:
            ports = {}
            for publish_port in self.config['publish_ports']:
                ports[publish_port] = publish_port
            opts['ports'] = ports
        except KeyError:
            pass
        try:
            image = self.config['image']
        except KeyError:
            image = 'kaboxer/'+self.args.app

        if 'run_as_root' not in self.config:
            self.config['run_as_root'] = False

        if self.config['run_as_root']:
            self.home_in = '/root'
        else:
            import pwd
            uid = os.getuid()
            uname = pwd.getpwuid(os.getuid()).pw_name
            gecos = pwd.getpwuid(os.getuid()).pw_gecos
            gid = pwd.getpwuid(os.getuid()).pw_gid
            gname = grp.getgrgid(gid).gr_name
            self.home_in = os.path.join('/home',uname)

        try:
            for mount in self.config['mounts']:
                s = mount['source']
                s = os.path.expanduser(s)
                try:
                    os.makedirs(s)
                except FileExistsError:
                    pass
                t = mount['target']
                if t == '~':
                    t = self.home_in
                else:
                    t = re.sub('^~/',self.home_in+'/',t)
                opts['mounts'].append(docker.types.Mount(t,s,type='bind'))
        except KeyError:
            pass

        if not self.config['run_as_root'] and not self.args.reuse_container:
            opts2 = opts.copy()
            opts2['detach'] = False
            opts2['tty'] = True
            precmds = [
                [ 'addgroup', '--debug', '--gid', str(gid), gname ],
                [ 'adduser', '--debug', '--uid', str(uid), '--gid', str(gid), '--home', self.home_in, '--gecos', gecos, '--disabled-password', uname ],
            ]
            container = self.docker_conn.containers.create(image, **opts2)
            opts['entrypoint'] = container.attrs['Config']['Entrypoint']
            container.remove()
            try:
                del (opts2['command'])
            except KeyError:
                pass
            for precmd in precmds:
                opts2['entrypoint'] = precmd
                container = self.docker_conn.containers.create(image, **opts2)
                container.start()
                container.wait()
                image = container.commit()
                container.remove()
            opts['user'] = uid
            opts['environment']['HOME'] = self.home_in

        if run_mode == 'cli':
            opts['tty'] = True
            opts['stdin_open'] = True
        elif run_mode == 'gui':
            self.create_xauth()
            opts['environment']['DISPLAY'] = os.getenv('DISPLAY')
            opts['environment']['XAUTHORITY'] = self.xauth_in
            opts['mounts'].append(docker.types.Mount(self.xauth_in,self.xauth_out,type='bind'))
        elif run_mode == 'headless':
            opts['name'] = self.args.app
        else:
            print ("Unknown run mode")
            sys.exit(1)
        if run_mode == 'gui' or ('allow_x11' in self.config and self.config['allow_x11']):
            xsock = '/tmp/.X11-unix'
            opts['mounts'].append(docker.types.Mount(xsock,xsock,type='bind'))
        if 'executable' in self.config:
            executable = self.config['executable']
        else:
            executable = self.args.executable
        if not isinstance(executable,list):
            executable = shlex.split(executable)
        try:
            executable.extend(shlex.split(self.config['extra_opts']))
        except KeyError:
            pass
        try:
            opts['entrypoint'] = ''
        except KeyError:
            pass

        if self.args.reuse_container:
            if run_mode == 'gui':
                self.create_xauth()
                bio = io.BytesIO()
                tf = tarfile.open(mode='w:',fileobj=bio)
                ti = tarfile.TarInfo()
                ti.name = self.xauth_in
                def tifilter(x):
                    if not self.config['run_as_root']:
                        x.uid = uid
                        x.gid = gid
                        x.uname = uname
                        x.gname = gname
                    return x
                tf.add(self.xauth_out, arcname=self.xauth_in, filter=tifilter)
                tf.close()
                container.put_archive('/', bio.getvalue())
            ex_with_env = ['env']
            for e in opts['environment']:
                ex_with_env.append("%s=%s" % (e, shlex.quote(opts['environment'][e])))
            ex_with_env.extend(executable)
            executable = ex_with_env
            dockerpty.exec_command(self.docker_conn.api, container.id, executable)
        else:
            opts['auto_remove'] = True
            container = self.docker_conn.containers.create(image, executable, **opts)
            for e in extranets:
                create_network(e).connect(container)
            dockerpty.start(self.docker_conn.api,container.id)

    def stop(self):
        self.read_config()
        run_mode = self.config['run_mode']
        try:
            image = self.config['image']
        except KeyError:
            image = 'kaboxer/'+self.args.app
        if run_mode == 'headless':
            containers = self.docker_conn.containers.list(filters={'name': self.args.app})
            container = containers[0]
            container.stop()
        else:
            print ("Can't stop a non-headless component")
            sys.exit(1)

    def build(self):
        if self.args.path is None:
            path = os.path.join('/usr/src/kaboxer', self.args.app)
        else:
            path = self.args.path
        self.docker_conn.images.build(path=path, tag='kaboxer/'+self.args.app+':latest', rm=True, forcerm=True)

    def save(self):
        images = self.docker_conn.images.list()
        for image in images:
            for tag in image.tags:
                if tag == 'kaboxer/'+self.args.app + ':latest':
                    f = open(self.args.file, 'wb')
                    for chunk in image.save():
                        f.write(chunk)
                    f.close()
                    return
        print("No image found")
        sys.exit(1)

    def load(self):
        f = open(self.args.file, 'rb')
        for image in self.docker_conn.images.load(f):
            image.tag('kaboxer/'+self.args.app, tag='latest')

    def pull(self):
        self.build()

    def purge(self):
        self.docker_conn.images.remove('kaboxer/'+self.args.app)

    def load_config(self):
        paths = [
            '.',
            '/etc/kaboxer',
            '/usr/share/kaboxer',
        ]
        for p in paths:
            config_file = os.path.join(p,self.args.app+'.yaml')
            if os.path.isfile(config_file):
                try:
                    return yaml.safe_load(open(config_file))
                except:
                    print("Error loading config file "+config_file)
                    sys.exit(1)
        print("Missing config file")
        sys.exit(1)

    def read_config(self):
        confs = self.load_config()
        if 'default_component' not in confs:
            # Single config
            self.config = confs
            return
        try:
            component = self.args.component
            confs['components'][component]
        except:
            component = confs['default_component']
        self.config = confs['components'][component]

    def create_network(self, netname):
        for n in self.docker_conn.networks.list():
            if n.name == netname:
                return n
        return self.docker_conn.networks.create(name=netname, driver='bridge')

    def create_xauth(self):
        if os.getenv('DISPLAY') is None:
            print("No DISPLAY set, are you running in a graphical session?")
            sys.exit(1)
        self.xauth_out = os.path.join(os.getenv('HOME'), '.docker.xauth')
        self.xauth_in = os.path.join(self.home_in,'.docker.xauth')
        f = subprocess.Popen(['xauth', 'nlist', os.getenv('DISPLAY')], stdout=subprocess.PIPE).stdout
        g = subprocess.Popen(['xauth', '-f', self.xauth_out, 'nmerge', '-'], stdin=subprocess.PIPE).stdin
        for l in f:
            l = str(l,'utf-8')
            l.strip()
            ll = re.sub('^[^ ]*', 'ffff', l) + "\n"
            g.write(bytes(ll, 'utf-8'))
        g.close()
        f.close()

kaboxer = Kaboxer()
kaboxer.go()
