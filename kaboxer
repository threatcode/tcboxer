#! /usr/bin/python3

import argparse
import yaml
import os
import sys
import re
import grp
import subprocess
import shlex
import shutil
import io
import tarfile
import glob
import docker
import dockerpty
import jinja2
import prompt_toolkit
import tempfile
import pathlib
import packaging.version as packaging_version

class Kaboxer:
    def __init__(self):
        self.parser = argparse.ArgumentParser()

        subparsers = self.parser.add_subparsers(title='subcommands', help='action to perform', dest='action', required=True)

        parser_run = subparsers.add_parser('run', help='run containerized app')
        parser_run.add_argument('app')
        parser_run.add_argument("--component", help='component to run')
        parser_run.add_argument("--reuse-container", action="store_true", help='run in existing container')
        parser_run.add_argument("--detach", help='run in the background', action="store_true")
        parser_run.add_argument("--prompt-before-detach", help='message to display before detaching')
        parser_run.add_argument('executable', nargs='*')
        parser_run.set_defaults(func=self.cmd_run)

        parser_stop = subparsers.add_parser('stop', help='stop running containerized app')
        parser_stop.add_argument('app')
        parser_stop.set_defaults(func=self.cmd_stop)

        parser_get_meta_file = subparsers.add_parser('get-meta-file', help='get installed get_meta_file of containerized app')
        parser_get_meta_file.add_argument('app')
        parser_get_meta_file.add_argument('file')
        parser_get_meta_file.set_defaults(func=self.cmd_get_meta_file)

        parser_prepare = subparsers.add_parser('prepare', help='prepare container')
        parser_prepare.add_argument('app')
        parser_prepare.set_defaults(func=self.cmd_prepare)

        parser_list = subparsers.add_parser('list', help='list installed containers')
        parser_list.set_defaults(func=self.cmd_list)

        parser_build = subparsers.add_parser('build', help='build image')
        parser_build.add_argument("--save", action="store_true", help='save container image after build')
        parser_build.add_argument("--version", help='app version')
        parser_build.add_argument("--ignore-version", action="store_true", help='ignore version checks')
        parser_build.add_argument("--tarball", help='tar file to save the image into')
        parser_build.add_argument('app', nargs='?')
        parser_build.add_argument('path', nargs='?')
        parser_build.set_defaults(func=self.cmd_build)

        parser_install = subparsers.add_parser('install', help='install image')
        parser_install.add_argument("--tarball", help='tar file to install')
        parser_install.add_argument("--destdir", help='build-time destination dir', default='')
        parser_install.add_argument("--prefix", help='prefix for the installation path', default='/usr/local')
        parser_install.add_argument("--skip-local-tarball", action="store_true", help='do not install tarball locally (if configured to use a registry)')
        parser_install.add_argument('app', nargs='?')
        parser_install.add_argument('path', nargs='?')
        parser_install.set_defaults(func=self.cmd_install)

        parser_clean = subparsers.add_parser('clean', help='clean directory')
        parser_clean.add_argument("--tarball", help='tar file to clean (if if the dir)')
        parser_clean.add_argument('app', nargs='?')
        parser_clean.add_argument('path', nargs='?')
        parser_clean.set_defaults(func=self.cmd clean)

        parser_pull = subparsers.add_parser('pull', help='fetch image')
        parser_pull.add_argument('app')
        parser_pull.set_defaults(func=self.cmd_pull)

        parser_save = subparsers.add_parser('save', help='save image')
        parser_save.add_argument('app')
        parser_save.add_argument('file')
        parser_save.set_defaults(func=self.cmd_save)

        parser_load = subparsers.add_parser('load', help='load image')
        parser_load.add_argument('app')
        parser_load.add_argument('file')
        parser_load.set_defaults(func=self.cmd_load)

        parser_purge = subparsers.add_parser('purge', help='purge image')
        parser_purge.add_argument('app')
        parser_purge.add_argument("--prune", action="store_true", help='prune unused images')
        parser_purge.set_defaults(func=self.cmd_purge)

        try:
            self.docker_conn = docker.from_env()
            self.docker_conn.containers.list()
        except:
            groups = list(map(lambda g: grp.getgrgid(g)[0], os.getgroups()))
            if 'docker' in groups:
                print ("No access to Docker even though you're a member of the docker group, is docker.service running?")
                sys.exit(1)
            else:
                if 'kaboxer' in groups:
                    nc = ['sudo', '-g', 'docker'] + sys.argv
                    sys.stdout.flush()
                    sys.stderr.flush()
                    os.execv('/usr/bin/sudo', nc)
                else:
                    print ("No access to Docker, are you a member of group docker or kaboxer?")
                    sys.exit(1)

        self.config_paths = [
            '.',
            '/etc/kaboxer',
            '/usr/local/share/kaboxer',
            '/usr/share/kaboxer',
        ]

    def go(self):
        self.args = self.parser.parse_args()
        self.args.func()

    def cmd_run(self):
        self.cmd_prepare()

        image = self.get_image_name()

        if self.args.reuse_container:
            containers = self.docker_conn.containers.list(filters={'name': self.args.app})
            container = containers[0]

        run_mode = self.component_config['run_mode']
        try:
            opts = self.component_config['docker_options']
        except:
            opts = {}
        if self.args.detach:
            if self.component_config['run_mode'] == 'headless':
                opts['detach'] = True
            else:
                print ("Can't detach a non-headless component")
                sys.exit(1)
        opts['environment'] = {}
        opts['mounts'] = []
        extranets = []
        try:
            netname = self.component_config['networks'][0]
            self.create_network(netname)
            opts['network'] = netname
            extranets = self.component_config['networks'][1:]
        except KeyError:
            pass
        try:
            ports = {}
            for publish_port in self.component_config['publish_ports']:
                ports[publish_port] = publish_port
            opts['ports'] = ports
        except KeyError:
            pass

        if 'run_as_root' not in self.component_config:
            self.component_config['run_as_root'] = False

        if self.component_config['run_as_root']:
            self.home_in = '/root'
        else:
            import pwd
            uid = os.getuid()
            uname = pwd.getpwuid(os.getuid()).pw_name
            gecos = pwd.getpwuid(os.getuid()).pw_gecos
            gid = pwd.getpwuid(os.getuid()).pw_gid
            gname = grp.getgrgid(gid).gr_name
            self.home_in = os.path.join('/home',uname)

        try:
            for mount in self.component_config['mounts']:
                s = mount['source']
                s = os.path.expanduser(s)
                try:
                    os.makedirs(s)
                except FileExistsError:
                    pass
                t = mount['target']
                if t == '~':
                    t = self.home_in
                else:
                    t = re.sub('^~/',self.home_in+'/',t)
                opts['mounts'].append(docker.types.Mount(t,s,type='bind'))
        except KeyError:
            pass

        if not self.component_config['run_as_root'] and not self.args.reuse_container:
            opts2 = opts.copy()
            opts2['detach'] = False
            opts2['tty'] = True
            precmds = [
                [ 'addgroup', '--debug', '--gid', str(gid), gname ],
                [ 'adduser', '--debug', '--uid', str(uid), '--gid', str(gid), '--home', self.home_in, '--gecos', gecos, '--disabled-password', uname ],
            ]
            container = self.docker_conn.containers.create(image, **opts2)
            opts['entrypoint'] = container.attrs['Config']['Entrypoint']
            container.remove()
            try:
                del (opts2['command'])
            except KeyError:
                pass
            for precmd in precmds:
                opts2['entrypoint'] = precmd
                container = self.docker_conn.containers.create(image, **opts2)
                container.start()
                container.wait()
                image = container.commit()
                container.remove()
            opts['user'] = uid
            opts['environment']['HOME'] = self.home_in

        if run_mode == 'cli':
            opts['tty'] = True
            opts['stdin_open'] = True
        elif run_mode == 'gui':
            self.create_xauth()
            opts['environment']['DISPLAY'] = os.getenv('DISPLAY')
            opts['environment']['XAUTHORITY'] = self.xauth_in
            opts['mounts'].append(docker.types.Mount(self.xauth_in,self.xauth_out,type='bind'))
        elif run_mode == 'headless':
            opts['name'] = self.args.app
        else:
            print ("Unknown run mode")
            sys.exit(1)
        if run_mode == 'gui' or ('allow_x11' in self.component_config and self.component_config['allow_x11']):
            xsock = '/tmp/.X11-unix'
            opts['mounts'].append(docker.types.Mount(xsock,xsock,type='bind'))
        if 'executable' in self.component_config:
            executable = self.component_config['executable']
        else:
            executable = self.args.executable
        if not isinstance(executable,list):
            executable = shlex.split(executable)
        try:
            executable.extend(shlex.split(self.component_config['extra_opts']))
        except KeyError:
            pass
        try:
            opts['entrypoint'] = ''
        except KeyError:
            pass

        if self.args.reuse_container:
            if run_mode == 'gui':
                self.create_xauth()
                bio = io.BytesIO()
                tf = tarfile.open(mode='w:',fileobj=bio)
                ti = tarfile.TarInfo()
                ti.name = self.xauth_in
                def tifilter(x):
                    if not self.component_config['run_as_root']:
                        x.uid = uid
                        x.gid = gid
                        x.uname = uname
                        x.gname = gname
                    return x
                tf.add(self.xauth_out, arcname=self.xauth_in, filter=tifilter)
                tf.close()
                container.put_archive('/', bio.getvalue())
            ex_with_env = ['env']
            for e in opts['environment']:
                ex_with_env.append("%s=%s" % (e, shlex.quote(opts['environment'][e])))
            ex_with_env.extend(executable)
            executable = ex_with_env
            dockerpty.exec_command(self.docker_conn.api, container.id, executable)
        else:
            opts['auto_remove'] = True
            container = self.docker_conn.containers.create(image, executable, **opts)
            for e in extranets:
                create_network(e).connect(container)
            dockerpty.start(self.docker_conn.api,container.id)
            if self.args.detach and self.args.prompt_before_detach:
                c = prompt_toolkit.prompt(self.args.prompt_before_detach)

    def cmd_stop(self):
        self.read_config()
        run_mode = self.component_config['run_mode']
        image = 'kaboxer/'+self.args.app
        if run_mode == 'headless':
            containers = self.docker_conn.containers.list(filters={'name': self.args.app})
            container = containers[0]
            container.stop()
        else:
            print ("Can't stop a non-headless component")
            sys.exit(1)

    def get_meta_file(self, image, filename):
        with tempfile.NamedTemporaryFile(mode='w+t',prefix="getmetafile") as tmp:
            self.extract_file_from_image(image,os.path.join('/kaboxer/',filename),tmp.name)
            v = str(open(tmp.name).read())
            return v

    def cmd_get_meta_file(self):
        self.read_config()
        image = 'kaboxer/'+self.args.app
        print(self.get_meta_file(image,self.args.file))

    def find_config_for_build_app(self):
        try:
            if self.args.path is None:
                path = os.getcwd()
            else:
                path = self.args.path
        except:
            path = os.getcwd()
        yamlfiles = []
        globs = [ 'kaboxer.yaml', '*.kaboxer.yaml' ]
        for g in globs:
            for f in glob.glob(os.path.join(path,g)):
                yamlfiles.append(f)
        if self.args.app is None:
            for f in yamlfiles:
                y = yaml.safe_load(open(f))
                try:
                    y['application']['id']
                    parsed_config = y
                    self.config_file = f
                    break
                except:
                    pass
        else:
            for f in yamlfiles:
                y = yaml.safe_load(open(f))
                try:
                    if y['application']['id'] == self.args.app:
                        parsed_config = y
                        self.config_file = f
                        break
                except:
                    pass
        try:
            app = parsed_config['application']['id']
        except:
            print("Failed to find appropriate kaboxer.yaml file")
            sys.exit(1)
        return parsed_config

    def do_version_checks(self,v,config):
        parsed_v = packaging_version.parse(v)
        try:
            minv = str(config['packaging']['min_upstream_version'])
            parsed_minv = packaging_version.parse(minv)
            if parsed_v < parsed_minv:
                raise Exception("Unsupported upstream version %s < %s" % (v, minv))
        except KeyError:
            pass
        try:
            maxv = str(config['packaging']['max_upstream_version'])
            parsed_maxv = packaging_version.parse(maxv)
            if parsed_v > parsed_maxv:
                raise Exception("Unsupported upstream version %s > %s" % (v, maxv))
        except KeyError:
            pass

    def cmd_build(self):
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        parsed_config = self.find_config_for_build_app()
        app = parsed_config['application']['id']
        try:
            df = os.path.join(path,parsed_config['build']['docker']['file'])
        except:
            df = os.path.join(path,'Dockerfile')
        tagname='kaboxer/'+app+':latest'
        buildargs = {}
        if self.args.version:
            if not self.args.ignore_version:
                try:
                    self.do_version_checks(self.args.version,parsed_config)
                except Exception as e:
                    print(str(e))
                    sys.exit(1)
            buildargs['KBX_APP_VERSION'] = self.args.version
        (image, _) = self.docker_conn.images.build(path=path, dockerfile=df, rm=True, forcerm=True, buildargs=buildargs)
        with tempfile.NamedTemporaryFile(mode='w+t') as tmp:
            try:
                self.extract_file_from_image(image,'/kaboxer/version',tmp.name)
                if not self.args.ignore_version:
                    saved_version = open(tmp.name).readline().strip()
                    try:
                        self.do_version_checks(saved_version,parsed_config)
                    except Exception as e:
                        self.docker_conn.images.remove(image=image.id)
                        print(str(e))
                        sys.exit(1)
            except Exception as e:
                if self.args.version:
                    tmp.write(self.args.version)
                else:
                    print("Unable to determine version (use --version?)")
                    self.docker_conn.images.remove(image=image.id)
                    sys.exit(1)
                tmp.flush()
                image = self.inject_file_into_image(image,tmp.name,'/kaboxer/version')
        with tempfile.NamedTemporaryFile(mode='w+t') as tmp:
            tmp.write(str(parsed_config['packaging']['revision'])+"\n")
            tmp.flush()
            image = self.inject_file_into_image(image,tmp.name,'/kaboxer/packaging-revision')
        with tempfile.NamedTemporaryFile(mode='w+t') as tmp:
            tmp.write(yaml.dump(sys.argv))
            tmp.flush()
            image = self.inject_file_into_image(image,tmp.name,'/kaboxer/kaboxer-build-cmd')
        image = self.inject_file_into_image(image,df,'/kaboxer/Dockerfile')
        with tempfile.NamedTemporaryFile(mode='w+t') as tmp:
            savedbuildargs = {
                'rm': True,
                'forcerm': True,
                'path': path,
                'dockerfile': df,
                'buildargs': buildargs
            }
            tmp.write(yaml.dump(savedbuildargs))
            tmp.flush()
            image = self.inject_file_into_image(image,tmp.name,'/kaboxer/docker-build-parameters')
        image.tag(tagname)
        if self.args.save:
            if self.args.tarball is not None:
                tarball = self.args.tarball
            else:
                tarball = os.path.join(path,parsed_config['application']['id']+'.tar')
            self.save_image_to_file(image,tarball)
        try:
            parsed_config['install']['desktop-files']
        except:
            self.gen_desktop_files()


    def gen_desktop_files(self):
        parsed_config = self.find_config_for_build_app()
        template_text = """[Desktop Entry]
Name={{ p.name }}
Comment={{ p.comment }}
Exec={{ p.exec }}
Icon=kaboxer-{{ p.appid }}
Terminal={{ p.terminal }}
Type=Application
Categories={{ p.categories }}

"""
        t = jinja2.Template(template_text)
        for component in parsed_config['components']:
            params = {
                'comment': parsed_config['application']['description'],
                'component': component,
                'appid': parsed_config['application']['id'],
                'categories': parsed_config['application']['categories'],
            }
            params['reuse_container'] = ''
            try:
                if parsed_config['components'][component]['reuse_container']:
                    params['reuse_container'] = '--reuse-container '
            except:
                pass
            try:
                component_name = parsed_config['components'][component]['name']
            except:
                component_name = parsed_config['application']['name']
            if parsed_config['components'][component]['run_mode'] == 'headless':
                # One .desktop file for starting
                params['name'] = "Start %s" % (component_name,)
                params['terminal'] = 'true'
                try:
                    detach_message = parsed_config['components'][component]['start_message']
                except:
                    detach_message = "%s started" % (component_name,)
                params['exec'] = "kaboxer run --detach --prompt_before_detach %s%s--component %s %s" % (shlex.quote(detach_message), params['reuse_container'], params['component'], params['appid'])
                ofname = 'kaboxer-%s-%s-start.desktop' % (parsed_config['application']['id'], component)
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))
                # One .desktop file for stopping
                params['name'] = "Stop %s" % (component_name,)
                params['terminal'] = 'false'
                params['exec'] = "kaboxer stop %s--component %s %s" % (params['reuse_container'], params['component'], params['appid'])
                ofname = 'kaboxer-%s-%s-stop.desktop' % (parsed_config['application']['id'], component)
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))
            else:
                params['name'] = component_name
                ofname = 'kaboxer-%s-%s.desktop' % (parsed_config['application']['id'], component)
                params['exec'] = "kaboxer run %s--component %s %s" % (params['reuse_container'], params['component'], params['appid'])
                if parsed_config['components'][component]['run_mode'] == 'cli':
                    params['terminal'] = 'true'
                else:
                    params['terminal'] = 'false'
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))

    def cmd_clean(self):
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        path = os.path.realpath(path)
        parsed_config = self.find_config_for_build_app()
        app = parsed_config['application']['id']
        if self.args.tarball is not None:
            tarball = self.args.tarball
        else:
            tarball = os.path.join(path,parsed_config['application']['id']+'.tar')
        if os.path.commonpath([path,tarball]) == path and os.path.isfile(tarball):
            os.unlink(tarball)

    def install_to_path(self,f,path):
        if self.args.destdir == '':
            builddestpath = path
        else:
            builddestpath = os.path.join(self.args.destdir, os.path.relpath(path,'/'))
        os.makedirs(builddestpath, exist_ok=True)
        shutil.copy(f,builddestpath)

    def cmd_install(self):
        main_destpath = os.path.join(self.args.prefix, 'share', 'kaboxer')
        parsed_config = self.find_config_for_build_app()
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        app = parsed_config['application']['id']
        # Install image tarball
        if not self.args.skip_local_tarball:
            if self.args.tarball is not None:
                tarball = self.args.tarball
            else:
                tarball = os.path.join(path,app+'.tar')
            try:
                self.install_to_path(tarball, main_destpath)
            except shutil.SameFileError:
                pass
        # Install kaboxer.yaml file
        # Update it first if we ship the tarball
        if self.args.skip_local_tarball:
            self.install_to_path(self.config_file, main_destpath)
        else:
            try:
                del(parsed_config['container']['origin']['registry'])
            except:
                pass
            if 'origin' not in parsed_config['container']:
                parsed_config['container']['origin'] = {}
            parsed_config['container']['origin']['tarball'] = os.path.join(main_destpath,app+'.tar')
            with tempfile.TemporaryDirectory() as td:
                tf = os.path.join(td,app+'.yaml')
                with open(tf,'w') as y:
                    y.write(yaml.dump(parsed_config))
                self.install_to_path(tf, main_destpath)
        # Install desktop file(s)
        try:
            desktopfiles = parsed_config['install']['desktop-files']
        except:
            desktopfiles = []
            for component in parsed_config['components']:
                if parsed_config['components'][component]['run_mode'] == 'headless':
                    desktopfiles.append('kaboxer-%s-%s-start.desktop' % (parsed_config['application']['id'], component))
                    desktopfiles.append('kaboxer-%s-%s-stop.desktop' % (parsed_config['application']['id'], component))
                else:
                    desktopfiles.append('kaboxer-%s-%s.desktop' % (parsed_config['application']['id'], component))
        for d in desktopfiles:
            self.install_to_path(d,os.path.join(self.args.prefix, 'share', 'applications'))
        # Install icon file(s)
        try:
            iconfile = parsed_config['install']['icon']
            (_,ife) = os.path.splitext(os.path.basename(iconfile))
            with tempfile.TemporaryDirectory() as td:
                renamed_icon = os.path.join(td, 'kaboxer-%s%s' % (parsed_config['application']['id'], ife))
                shutil.copy(iconfile,renamed_icon)
                self.install_to_path(renamed_icon,os.path.join(self.args.prefix, 'share', 'icons'))
        except KeyError:
            pass
        try:
            iconfile = parsed_config['install']['extract-icon']
            (_,ife) = os.path.splitext(os.path.basename(iconfile))
            with tempfile.TemporaryDirectory() as td:
                renamed_icon = os.path.join(td, 'kaboxer-%s%s' % (parsed_config['application']['id'], ife))
                self.extract_file_from_image('kaboxer/'+parsed_config['application']['id'],iconfile,renamed_icon)
                self.install_to_path(renamed_icon,os.path.join(self.args.prefix, 'share', 'icons'))
        except KeyError:
            pass

    def extract_file_from_image(self,image,infile,outfile):
        temp_container = self.docker_conn.containers.create(image)
        (bits, stat) = temp_container.get_archive(infile)
        with tempfile.TemporaryFile() as temptar:
            for chunk in bits:
                temptar.write(chunk)
            temptar.seek(0)
            tf = tarfile.open(fileobj=temptar)
            ti = tf.getmembers()[0]
            with tempfile.TemporaryDirectory() as td:
                tf.extract(ti,path=td,set_attrs=False)
                shutil.move(os.path.join(td,ti.name), outfile)
        temp_container.remove()

    def inject_file_into_image(self,image,outfile,infile):
        temp_container = self.docker_conn.containers.create(image)
        with tempfile.TemporaryFile() as temptar:
            tf = tarfile.open(fileobj=temptar,mode='w')
            (dirname,filename) = os.path.split(infile)
            p = pathlib.Path(dirname)
            for parent in reversed(p.parents):
                ti = tarfile.TarInfo(name=str(parent))
                ti.type = tarfile.DIRTYPE
                tf.addfile(ti)
            ti = tarfile.TarInfo(name=infile)
            ti.size = os.stat(outfile).st_size
            tf.addfile(ti, fileobj=open(outfile,mode='rb'))
            tf.close()
            temptar.seek(0)
            buf = b''
            while True:
                b = temptar.read()
                if not b:
                    break
                buf += b
            temp_container.put_archive('/',buf)
        image = temp_container.commit()
        temp_container.remove()
        return image

    def cmd_save(self):
        images = self.docker_conn.images.list()
        for image in images:
            for tag in image.tags:
                if tag == 'kaboxer/'+self.args.app + ':latest':
                    self.save_image_to_file(image,self.args.file)
                    return
        print("No image found")
        sys.exit(1)

    def save_image_to_file(self,image,destfile):
        with open(destfile, 'wb') as f:
            for chunk in image.save():
                f.write(chunk)

    def load_image(self, tarfile):
        f = open(tarfile, 'rb')
        for image in self.docker_conn.images.load(f):
            image.tag('kaboxer/'+self.args.app, tag='latest')

    def cmd_load(self):
        self.load_image(self.args.file)

    def find_image(self, name):
        images = self.docker_conn.images.list()
        for image in images:
            for tag in image.tags:
                if tag == name:
                    return True
        return False

    def get_image_name(self):
        self.read_config()
        try:
            if 'registry' in self.config['container']['origin']:
                registry = self.config['container']['origin']['registry']['url']
                try:
                    image = self.config['container']['origin']['registry']['image']
                except KeyError:
                    image = self.config['application']['id']
                return "%s/%s" % (registry, image)
        except KeyError:
            pass
        return "kaboxer/%s" % (self.config['application']['id'],)

    def cmd_prepare(self):
        self.read_config()
        full_image_name = self.get_image_name()
        if self.find_image(full_image_name+':latest'):
            return
        try:
            if 'registry' in self.config['container']['origin']:
                if not self.find_image(full_image_name+':latest'):
                    #print("Pulling image from registry")
                    self.docker_conn.images.pull(full_image_name)
                return
            if 'tarball' in self.config['container']['origin']:
                paths = [
                    '.',
                    '/usr/local/share/kaboxer',
                    '/usr/share/kaboxer',
                ]
                for p in paths:
                    tarfile = os.path.join(p,self.config['container']['origin'])
                    if os.path.isfile(tarfile):
                        #print("Loading image from "+tarfile)
                        self.load_image(tarfile)
                    return
        except KeyError:
            pass
        if not self.find_image(full_image_name+':latest'):
            paths = [
                '.',
                '/usr/local/share/kaboxer',
                '/usr/share/kaboxer',
            ]
            for p in paths:
                tarfile = os.path.join(p,self.config['application']['id']+'.tar')
                if os.path.isfile(tarfile):
                    #print("Loading image from "+tarfile)
                    self.load_image(tarfile)
                    return
        print("Cannot prepare image")
        sys.exit(1)

    def cmd_pull(self):
        self.cmd_build()

    def cmd_purge(self):
        self.docker_conn.images.remove('kaboxer/'+self.args.app)
        if self.args.prune:
            self.docker_conn.images.prune(filters={'dangling': True})

    def cmd_list(self):
        yamlfiles = []
        globs = [ 'kaboxer.yaml', '*.yaml' ]
        installed_apps = {}
        for p in self.config_paths:
            for g in globs:
                for f in glob.glob(os.path.join(p,g)):
                    try:
                        y = yaml.safe_load(open(f))
                        aid = y['application']['id']
                        installed_apps[aid] = self.get_meta_file('kaboxer/'+aid,'version').strip()
                    except:
                        pass
        for aid in installed_apps:
            print("%s: %s" % (aid, installed_apps[aid]))

    def load_config(self):
        for p in self.config_paths:
            for filename in [ self.args.app+'.yaml', 'kaboxer.yaml' ]:
                config_file = os.path.join(p,filename)
                if os.path.isfile(config_file):
                    try:
                        y = yaml.safe_load(open(config_file))
                        if y['application']['id'] == self.args.app:
                            return y
                    except:
                        pass
        print("Could not find appropriate config file")
        sys.exit(1)

    def read_config(self):
        self.config = self.load_config()
        # If a component was specified
        try:
            component = self.args.component
            self.component_config = self.config['components'][component]
            return
        except:
            pass
        # If a default component is listed in the config file
        try:
            component = self.config['container']['default_component']
            self.component_config = self.config['components'][component]
            return
        except:
            pass
        # If there is a component called "default"
        try:
            self.component_config = self.config['components']['default']
            return
        except:
            pass
        # Otherwise take the first component
        try:
            components = sorted(self.config['components'].keys())
            component = components[0]
            self.component_config = self.config['components'][component]
            return
        except:
            pass
        print("Can't find an appropriate component")
        sys.exit(1)

    def create_network(self, netname):
        for n in self.docker_conn.networks.list():
            if n.name == netname:
                return n
        return self.docker_conn.networks.create(name=netname, driver='bridge')

    def create_xauth(self):
        if os.getenv('DISPLAY') is None:
            print("No DISPLAY set, are you running in a graphical session?")
            sys.exit(1)
        self.xauth_out = os.path.join(os.getenv('HOME'), '.docker.xauth')
        self.xauth_in = os.path.join(self.home_in,'.docker.xauth')
        f = subprocess.Popen(['xauth', 'nlist', os.getenv('DISPLAY')], stdout=subprocess.PIPE).stdout
        g = subprocess.Popen(['xauth', '-f', self.xauth_out, 'nmerge', '-'], stdin=subprocess.PIPE).stdin
        for l in f:
            l = str(l,'utf-8')
            l.strip()
            ll = re.sub('^[^ ]*', 'ffff', l) + "\n"
            g.write(bytes(ll, 'utf-8'))
        g.close()
        f.close()

kaboxer = Kaboxer()
kaboxer.go()
