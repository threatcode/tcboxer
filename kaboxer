#! /usr/bin/python3

import argparse
import yaml
import os
import sys
import re
import grp
import subprocess
import shlex
import shutil
import io
import tarfile
import glob
import docker
import dockerpty
import jinja2
import prompt_toolkit
import tempfile

class Kaboxer:
    def __init__(self):
        self.parser = argparse.ArgumentParser()

        subparsers = self.parser.add_subparsers(title='subcommands', help='action to perform', dest='action', required=True)

        parser_run = subparsers.add_parser('run', help='run containerized app')
        parser_run.add_argument('app')
        parser_run.add_argument("--component", help='component to run')
        parser_run.add_argument("--reuse-container", action="store_true", help='run in existing container')
        parser_run.add_argument("--detach", help='run in the background', action="store_true")
        parser_run.add_argument("--prompt-before-detach", help='message to display before detaching')
        parser_run.add_argument('executable', nargs='*')
        parser_run.set_defaults(func=self.run)

        parser_stop = subparsers.add_parser('stop', help='stop running containerized app')
        parser_stop.add_argument('app')
        parser_stop.set_defaults(func=self.stop)

        parser_prepare = subparsers.add_parser('prepare', help='prepare container')
        parser_prepare.add_argument('app')
        parser_prepare.set_defaults(func=self.prepare)

        parser_build = subparsers.add_parser('build', help='build image')
        parser_build.add_argument("--save", action="store_true", help='save container image after build')
        parser_build.add_argument("--tarball", help='tar file to save the image into')
        parser_build.add_argument('app', nargs='?')
        parser_build.add_argument('path', nargs='?')
        parser_build.set_defaults(func=self.build)

        parser_install = subparsers.add_parser('install', help='install image')
        parser_install.add_argument("--tarball", help='tar file to install')
        parser_install.add_argument("--destdir", help='build-time destination dir', default='')
        parser_install.add_argument("--prefix", help='prefix for the installation path', default='/usr/local')
        parser_install.add_argument("--skip-local-tarball", action="store_true", help='do not install tarball locally (if configured to use a registry)')
        parser_install.add_argument('app', nargs='?')
        parser_install.add_argument('path', nargs='?')
        parser_install.set_defaults(func=self.install)

        parser_clean = subparsers.add_parser('clean', help='clean directory')
        parser_clean.add_argument("--tarball", help='tar file to clean (if if the dir)')
        parser_clean.add_argument('app', nargs='?')
        parser_clean.add_argument('path', nargs='?')
        parser_clean.set_defaults(func=self.clean)

        parser_pull = subparsers.add_parser('pull', help='fetch image')
        parser_pull.add_argument('app')
        parser_pull.set_defaults(func=self.pull)

        parser_pull = subparsers.add_parser('save', help='save image')
        parser_pull.add_argument('app')
        parser_pull.add_argument('file')
        parser_pull.set_defaults(func=self.save)

        parser_pull = subparsers.add_parser('load', help='load image')
        parser_pull.add_argument('app')
        parser_pull.add_argument('file')
        parser_pull.set_defaults(func=self.load)

        parser_purge = subparsers.add_parser('purge', help='purge image')
        parser_purge.add_argument('app')
        parser_purge.set_defaults(func=self.purge)

        try:
            self.docker_conn = docker.from_env()
            self.docker_conn.containers.list()
        except:
            groups = list(map(lambda g: grp.getgrgid(g)[0], os.getgroups()))
            if 'docker' in groups:
                print ("No access to Docker even though you're a member of the docker group, is docker.service running?")
                sys.exit(1)
            else:
                if 'kaboxer' in groups:
                    nc = ['sudo', '-g', 'docker'] + sys.argv
                    sys.stdout.flush()
                    sys.stderr.flush()
                    os.execv('/usr/bin/sudo', nc)
                else:
                    print ("No access to Docker, are you a member of group docker or kaboxer?")
                    sys.exit(1)

    def go(self):
        self.args = self.parser.parse_args()
        self.args.func()

    def run(self):
        self.prepare()

        image = self._get_image_name()

        if self.args.reuse_container:
            containers = self.docker_conn.containers.list(filters={'name': self.args.app})
            container = containers[0]

        run_mode = self.component_config['run_mode']
        try:
            opts = self.component_config['docker_options']
        except:
            opts = {}
        if self.args.detach:
            if self.component_config['run_mode'] == 'headless':
                opts['detach'] = True
            else:
                print ("Can't detach a non-headless component")
                sys.exit(1)
        opts['environment'] = {}
        opts['mounts'] = []
        extranets = []
        try:
            netname = self.component_config['networks'][0]
            self.create_network(netname)
            opts['network'] = netname
            extranets = self.component_config['networks'][1:]
        except KeyError:
            pass
        try:
            ports = {}
            for publish_port in self.component_config['publish_ports']:
                ports[publish_port] = publish_port
            opts['ports'] = ports
        except KeyError:
            pass

        if 'run_as_root' not in self.component_config:
            self.component_config['run_as_root'] = False

        if self.component_config['run_as_root']:
            self.home_in = '/root'
        else:
            import pwd
            uid = os.getuid()
            uname = pwd.getpwuid(os.getuid()).pw_name
            gecos = pwd.getpwuid(os.getuid()).pw_gecos
            gid = pwd.getpwuid(os.getuid()).pw_gid
            gname = grp.getgrgid(gid).gr_name
            self.home_in = os.path.join('/home',uname)

        try:
            for mount in self.component_config['mounts']:
                s = mount['source']
                s = os.path.expanduser(s)
                try:
                    os.makedirs(s)
                except FileExistsError:
                    pass
                t = mount['target']
                if t == '~':
                    t = self.home_in
                else:
                    t = re.sub('^~/',self.home_in+'/',t)
                opts['mounts'].append(docker.types.Mount(t,s,type='bind'))
        except KeyError:
            pass

        if not self.component_config['run_as_root'] and not self.args.reuse_container:
            opts2 = opts.copy()
            opts2['detach'] = False
            opts2['tty'] = True
            precmds = [
                [ 'addgroup', '--debug', '--gid', str(gid), gname ],
                [ 'adduser', '--debug', '--uid', str(uid), '--gid', str(gid), '--home', self.home_in, '--gecos', gecos, '--disabled-password', uname ],
            ]
            container = self.docker_conn.containers.create(image, **opts2)
            opts['entrypoint'] = container.attrs['Config']['Entrypoint']
            container.remove()
            try:
                del (opts2['command'])
            except KeyError:
                pass
            for precmd in precmds:
                opts2['entrypoint'] = precmd
                container = self.docker_conn.containers.create(image, **opts2)
                container.start()
                container.wait()
                image = container.commit()
                container.remove()
            opts['user'] = uid
            opts['environment']['HOME'] = self.home_in

        if run_mode == 'cli':
            opts['tty'] = True
            opts['stdin_open'] = True
        elif run_mode == 'gui':
            self.create_xauth()
            opts['environment']['DISPLAY'] = os.getenv('DISPLAY')
            opts['environment']['XAUTHORITY'] = self.xauth_in
            opts['mounts'].append(docker.types.Mount(self.xauth_in,self.xauth_out,type='bind'))
        elif run_mode == 'headless':
            opts['name'] = self.args.app
        else:
            print ("Unknown run mode")
            sys.exit(1)
        if run_mode == 'gui' or ('allow_x11' in self.component_config and self.component_config['allow_x11']):
            xsock = '/tmp/.X11-unix'
            opts['mounts'].append(docker.types.Mount(xsock,xsock,type='bind'))
        if 'executable' in self.component_config:
            executable = self.component_config['executable']
        else:
            executable = self.args.executable
        if not isinstance(executable,list):
            executable = shlex.split(executable)
        try:
            executable.extend(shlex.split(self.component_config['extra_opts']))
        except KeyError:
            pass
        try:
            opts['entrypoint'] = ''
        except KeyError:
            pass

        if self.args.reuse_container:
            if run_mode == 'gui':
                self.create_xauth()
                bio = io.BytesIO()
                tf = tarfile.open(mode='w:',fileobj=bio)
                ti = tarfile.TarInfo()
                ti.name = self.xauth_in
                def tifilter(x):
                    if not self.component_config['run_as_root']:
                        x.uid = uid
                        x.gid = gid
                        x.uname = uname
                        x.gname = gname
                    return x
                tf.add(self.xauth_out, arcname=self.xauth_in, filter=tifilter)
                tf.close()
                container.put_archive('/', bio.getvalue())
            ex_with_env = ['env']
            for e in opts['environment']:
                ex_with_env.append("%s=%s" % (e, shlex.quote(opts['environment'][e])))
            ex_with_env.extend(executable)
            executable = ex_with_env
            dockerpty.exec_command(self.docker_conn.api, container.id, executable)
        else:
            opts['auto_remove'] = True
            container = self.docker_conn.containers.create(image, executable, **opts)
            for e in extranets:
                create_network(e).connect(container)
            dockerpty.start(self.docker_conn.api,container.id)
            if self.args.detach and self.args.prompt_before_detach:
                c = prompt_toolkit.prompt(self.args.prompt_before_detach)

    def stop(self):
        self.read_config()
        run_mode = self.component_config['run_mode']
        try:
            image = self.component_config['image']
        except KeyError:
            image = 'kaboxer/'+self.args.app
        if run_mode == 'headless':
            containers = self.docker_conn.containers.list(filters={'name': self.args.app})
            container = containers[0]
            container.stop()
        else:
            print ("Can't stop a non-headless component")
            sys.exit(1)

    def find_config_for_build_app(self):
        try:
            if self.args.path is None:
                path = os.getcwd()
            else:
                path = self.args.path
        except:
            path = os.getcwd()
        yamlfiles = []
        globs = [ 'kaboxer.yaml', '*.kaboxer.yaml' ]
        for g in globs:
            for f in glob.glob(os.path.join(path,g)):
                try:
                    yamlfiles.append(f)
                except:
                    pass
        if self.args.app is None:
            for f in yamlfiles:
                y = yaml.safe_load(open(f))
                try:
                    y['application']['id']
                    parsed_config = y
                    self.config_file = f
                    break
                except:
                    pass
        else:
            for f in yamlfiles:
                y = yaml.safe_load(open(f))
                try:
                    if y['application']['id'] == self.args.app:
                        parsed_config = y
                        self.config_file = f
                        break
                except:
                    pass
        try:
            app = parsed_config['application']['id']
        except:
            print("Failed to find appropriate kaboxer.yaml file")
            sys.exit(1)
        return parsed_config

    def build(self):
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        parsed_config = self.find_config_for_build_app()
        app = parsed_config['application']['id']
        try:
            df = os.path.join(path,parsed_config['build']['docker']['file'])
        except:
            df = os.path.join(path,'Dockerfile')
        (image, _) = self.docker_conn.images.build(path=path, tag='kaboxer/'+app+':latest', dockerfile=df, rm=True, forcerm=True)
        if self.args.save:
            if self.args.tarball is not None:
                tarball = self.args.tarball
            else:
                tarball = os.path.join(path,parsed_config['application']['id']+'.tar')
            self.save_image_to_file(image,tarball)
        try:
            parsed_config['install']['desktop-files']
        except:
            self._gen_desktop_files()

    def _gen_desktop_files(self):
        parsed_config = self.find_config_for_build_app()
        template_text = """[Desktop Entry]
Name={{ p.name }}
Comment={{ p.comment }}
Exec={{ p.exec }}
Icon=kaboxer-{{ p.appid }}
Terminal={{ p.terminal }}
Type=Application
Categories={{ p.categories }}

"""
        t = jinja2.Template(template_text)
        for component in parsed_config['components']:
            params = {
                'comment': parsed_config['application']['description'],
                'component': component,
                'appid': parsed_config['application']['id'],
                'categories': parsed_config['application']['categories'],
            }
            params['reuse_container'] = ''
            try:
                if parsed_config['components'][component]['reuse_container']:
                    params['reuse_container'] = '--reuse-container '
            except:
                pass
            try:
                component_name = parsed_config['components'][component]['name']
            except:
                component_name = parsed_config['application']['name']
            if parsed_config['components'][component]['run_mode'] == 'headless':
                # One .desktop file for starting
                params['name'] = "Start %s" % (component_name,)
                params['terminal'] = 'true'
                try:
                    detach_message = parsed_config['components'][component]['start_message']
                except:
                    detach_message = "%s started" % (component_name,)
                params['exec'] = "kaboxer run --detach --prompt_before_detach %s%s--component %s %s" % (shlex.quote(detach_message), params['reuse_container'], params['component'], params['appid'])
                ofname = 'kaboxer-%s-%s-start.desktop' % (parsed_config['application']['id'], component)
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))
                # One .desktop file for stopping
                params['name'] = "Stop %s" % (component_name,)
                params['terminal'] = 'false'
                params['exec'] = "kaboxer stop %s--component %s %s" % (params['reuse_container'], params['component'], params['appid'])
                ofname = 'kaboxer-%s-%s-stop.desktop' % (parsed_config['application']['id'], component)
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))
            else:
                params['name'] = component_name
                ofname = 'kaboxer-%s-%s.desktop' % (parsed_config['application']['id'], component)
                params['exec'] = "kaboxer run %s--component %s %s" % (params['reuse_container'], params['component'], params['appid'])
                if parsed_config['components'][component]['run_mode'] == 'cli':
                    params['terminal'] = 'true'
                else:
                    params['terminal'] = 'false'
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))

    def clean(self):
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        path = os.path.realpath(path)
        parsed_config = self.find_config_for_build_app()
        app = parsed_config['application']['id']
        if self.args.tarball is not None:
            tarball = self.args.tarball
        else:
            tarball = os.path.join(path,parsed_config['application']['id']+'.tar')
        if os.path.commonpath([path,tarball]) == path and os.path.isfile(tarball):
            os.unlink(tarball)

    def _install_to_path(self,f,path):
        if self.args.destdir == '':
            builddestpath = path
        else:
            builddestpath = os.path.join(self.args.destdir, os.path.relpath(path,'/'))
        os.makedirs(builddestpath, exist_ok=True)
        shutil.copy(f,builddestpath)

    def install(self):
        main_destpath = os.path.join(self.args.prefix, 'share', 'kaboxer')
        parsed_config = self.find_config_for_build_app()
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        app = parsed_config['application']['id']
        # Install image tarball
        if not self.args.skip_local_tarball:
            if self.args.tarball is not None:
                tarball = self.args.tarball
            else:
                tarball = os.path.join(path,app+'.tar')
            try:
                self._install_to_path(tarball, main_destpath)
            except shutil.SameFileError:
                pass
        # Install kaboxer.yaml file
        # Update it first if we ship the tarball
        if self.args.skip_local_tarball:
            self._install_to_path(self.config_file, main_destpath)
        else:
            try:
                del(parsed_config['container']['origin']['registry'])
            except:
                pass
            if 'origin' not in parsed_config['container']:
                parsed_config['container']['origin'] = {}
            parsed_config['container']['origin']['tarball'] = os.path.join(main_destpath,app+'.tar')
            with tempfile.TemporaryDirectory() as td:
                tf = os.path.join(td,app+'.yaml')
                with open(tf,'w') as y:
                    y.write(yaml.dump(parsed_config))
                self._install_to_path(tf, main_destpath)
        # Install desktop file(s)
        try:
            desktopfiles = parsed_config['install']['desktop-files']
        except:
            desktopfiles = []
            for component in parsed_config['components']:
                if parsed_config['components'][component]['run_mode'] == 'headless':
                    desktopfiles.append('kaboxer-%s-%s-start.desktop' % (parsed_config['application']['id'], component))
                    desktopfiles.append('kaboxer-%s-%s-stop.desktop' % (parsed_config['application']['id'], component))
                else:
                    desktopfiles.append('kaboxer-%s-%s.desktop' % (parsed_config['application']['id'], component))
        for d in desktopfiles:
            self._install_to_path(d,os.path.join(self.args.prefix, 'share', 'applications'))
        # Install icon file(s)
        try:
            iconfile = parsed_config['install']['icon']
            (_,ife) = os.path.splitext(os.path.basename(iconfile))
            with tempfile.TemporaryDirectory() as td:
                renamed_icon = os.path.join(td, 'kaboxer-%s%s' % (parsed_config['application']['id'], ife))
                shutil.copy(iconfile,renamed_icon)
                self._install_to_path(renamed_icon,os.path.join(self.args.prefix, 'share', 'icons'))
        except KeyError:
            pass
        try:
            iconfile = parsed_config['install']['extract-icon']
            (_,ife) = os.path.splitext(os.path.basename(iconfile))
            with tempfile.TemporaryDirectory() as td:
                renamed_icon = os.path.join(td, 'kaboxer-%s%s' % (parsed_config['application']['id'], ife))
                temp_container = self.docker_conn.containers.create('kaboxer/'+parsed_config['application']['id'])
                container_id = temp_container.id
                subprocess.call("docker cp %s:%s %s" % (container_id, iconfile, renamed_icon),
                                shell=True)
                temp_container.remove()
                self._install_to_path(renamed_icon,os.path.join(self.args.prefix, 'share', 'icons'))
        except KeyError:
            pass

    def save(self):
        images = self.docker_conn.images.list()
        for image in images:
            for tag in image.tags:
                if tag == 'kaboxer/'+self.args.app + ':latest':
                    self.save_image_to_file(image,self.args.file)
                    return
        print("No image found")
        sys.exit(1)

    def save_image_to_file(self,image,destfile):
        with open(destfile, 'wb') as f:
            for chunk in image.save():
                f.write(chunk)

    def _load_image(self, tarfile):
        f = open(tarfile, 'rb')
        for image in self.docker_conn.images.load(f):
            image.tag('kaboxer/'+self.args.app, tag='latest')

    def load(self):
        self._load_image(self.args.file)

    def _find_image(self, name):
        images = self.docker_conn.images.list()
        for image in images:
            for tag in image.tags:
                if tag == name:
                    return True
        return False

    def _get_image_name(self):
        self.read_config()
        try:
            if 'registry' in self.config['container']['origin']:
                registry = self.config['container']['origin']['registry']['url']
                try:
                    image = self.config['container']['origin']['registry']['image']
                except KeyError:
                    image = self.config['application']['id']
            return "%s/%s" % (registry, image)
        except KeyError:
            pass
        return "kaboxer/%s" % (self.config['application']['id'],)

    def prepare(self):
        self.read_config()
        full_image_name = self._get_image_name()
        if self._find_image(full_image_name+':latest'):
            return
        try:
            if 'registry' in self.config['container']['origin']:
                if not self._find_image(full_image_name+':latest'):
                    print("Pulling image from registry")
                    self.docker_conn.images.pull(full_image_name)
                return
            if 'tarball' in self.config['container']['origin']:
                paths = [
                    '.',
                    '/usr/local/share/kaboxer',
                    '/usr/share/kaboxer',
                ]
                for p in paths:
                    tarfile = os.path.join(p,self.config['container']['origin'])
                    if os.path.isfile(tarfile):
                        print("Loading image from "+tarfile)
                        self._load_image(tarfile)
                    return
        except KeyError:
            pass
        if not self._find_image(full_image_name+':latest'):
            paths = [
                '.',
                '/usr/local/share/kaboxer',
                '/usr/share/kaboxer',
            ]
            for p in paths:
                tarfile = os.path.join(p,self.config['application']['id']+'.tar')
                if os.path.isfile(tarfile):
                    print("Loading image from "+tarfile)
                    self._load_image(tarfile)
                    return
        print("Cannot prepare image")
        sys.exit(1)

    def pull(self):
        self.build()

    def purge(self):
        self.docker_conn.images.remove('kaboxer/'+self.args.app)

    def load_config(self):
        paths = [
            '.',
            '/etc/kaboxer',
            '/usr/local/share/kaboxer',
            '/usr/share/kaboxer',
        ]
        for p in paths:
            for filename in [ self.args.app+'.yaml', 'kaboxer.yaml' ]:
                config_file = os.path.join(p,filename)
                if os.path.isfile(config_file):
                    try:
                        y = yaml.safe_load(open(config_file))
                        if y['application']['id'] == self.args.app:
                            return y
                    except:
                        pass
        print("Could not find appropriate config file")
        sys.exit(1)

    def read_config(self):
        self.config = self.load_config()
        # If a component was specified
        try:
            component = self.args.component
            self.component_config = self.config['components'][component]
            return
        except:
            pass
        # If a default component is listed in the config file
        try:
            component = self.config['container']['default_component']
            self.component_config = self.config['components'][component]
            return
        except:
            pass
        # If there is a component called "default"
        try:
            self.component_config = self.config['components']['default']
            return
        except:
            pass
        # Otherwise take the first component
        try:
            components = sorted(self.config['components'].keys())
            component = components[0]
            self.component_config = self.config['components'][component]
            return
        except:
            pass
        print("Can't find an appropriate component")
        sys.exit(1)

    def create_network(self, netname):
        for n in self.docker_conn.networks.list():
            if n.name == netname:
                return n
        return self.docker_conn.networks.create(name=netname, driver='bridge')

    def create_xauth(self):
        if os.getenv('DISPLAY') is None:
            print("No DISPLAY set, are you running in a graphical session?")
            sys.exit(1)
        self.xauth_out = os.path.join(os.getenv('HOME'), '.docker.xauth')
        self.xauth_in = os.path.join(self.home_in,'.docker.xauth')
        f = subprocess.Popen(['xauth', 'nlist', os.getenv('DISPLAY')], stdout=subprocess.PIPE).stdout
        g = subprocess.Popen(['xauth', '-f', self.xauth_out, 'nmerge', '-'], stdin=subprocess.PIPE).stdin
        for l in f:
            l = str(l,'utf-8')
            l.strip()
            ll = re.sub('^[^ ]*', 'ffff', l) + "\n"
            g.write(bytes(ll, 'utf-8'))
        g.close()
        f.close()

kaboxer = Kaboxer()
kaboxer.go()
