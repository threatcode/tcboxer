#! /usr/bin/python3

import argparse
import yaml
import os
import sys
import re
import grp
import subprocess
import shlex
import shutil
import io
import tarfile
import glob
import docker
import dockerpty
import jinja2
import prompt_toolkit

class Kaboxer:
    def __init__(self):
        self.parser = argparse.ArgumentParser()

        subparsers = self.parser.add_subparsers(title='subcommands', help='action to perform', dest='action', required=True)

        parser_run = subparsers.add_parser('run', help='run containerized app')
        parser_run.add_argument('app')
        parser_run.add_argument("--component", help='component to run')
        parser_run.add_argument("--reuse-container", action="store_true", help='run in existing container')
        parser_run.add_argument("--detach", help='run in the background', action="store_true")
        parser_run.add_argument("--prompt-before-detach", help='message to display before detaching')
        parser_run.add_argument('executable', nargs='*')
        parser_run.set_defaults(func=self.run)

        parser_stop = subparsers.add_parser('stop', help='stop running containerized app')
        parser_stop.add_argument('app')
        parser_stop.set_defaults(func=self.stop)

        parser_build = subparsers.add_parser('build', help='build image')
        parser_build.add_argument("--save", action="store_true", help='save container image after build')
        parser_build.add_argument("--tarball", help='tar file to save the image into')
        parser_build.add_argument('app', nargs='?')
        parser_build.add_argument('path', nargs='?')
        parser_build.set_defaults(func=self.build)

        parser_install = subparsers.add_parser('install', help='install image')
        parser_install.add_argument("--tarball", help='tar file to install')
        parser_install.add_argument("--destdir", help='build-time destination dir', default='')
        parser_install.add_argument("--prefix", help='prefix for the installation path', default='/usr/local')
        parser_install.add_argument('app', nargs='?')
        parser_install.add_argument('path', nargs='?')
        parser_install.set_defaults(func=self.install)

        parser_clean = subparsers.add_parser('clean', help='clean directory')
        parser_clean.add_argument("--tarball", help='tar file to clean (if if the dir)')
        parser_clean.add_argument('app', nargs='?')
        parser_clean.add_argument('path', nargs='?')
        parser_clean.set_defaults(func=self.clean)

        parser_pull = subparsers.add_parser('pull', help='fetch image')
        parser_pull.add_argument('app')
        parser_pull.set_defaults(func=self.pull)

        parser_pull = subparsers.add_parser('save', help='save image')
        parser_pull.add_argument('app')
        parser_pull.add_argument('file')
        parser_pull.set_defaults(func=self.save)

        parser_pull = subparsers.add_parser('load', help='load image')
        parser_pull.add_argument('app')
        parser_pull.add_argument('file')
        parser_pull.set_defaults(func=self.load)

        parser_purge = subparsers.add_parser('purge', help='purge image')
        parser_purge.add_argument('app')
        parser_purge.set_defaults(func=self.purge)

        try:
            self.docker_conn = docker.from_env()
            self.docker_conn.containers.list()
        except:
            groups = list(map(lambda g: grp.getgrgid(g)[0], os.getgroups()))
            if 'docker' in groups:
                print ("No access to Docker even though you're a member of the docker group, is docker.service running?")
                sys.exit(1)
            else:
                if 'kaboxer' in groups:
                    nc = ['sudo', '-g', 'docker'] + sys.argv
                    sys.stdout.flush()
                    sys.stderr.flush()
                    os.execv('/usr/bin/sudo', nc)
                else:
                    print ("No access to Docker, are you a member of group docker or kaboxer?")
                    sys.exit(1)

    def go(self):
        self.args = self.parser.parse_args()
        self.args.func()

    def run(self):
        self.read_config()

        if self.args.reuse_container:
            containers = self.docker_conn.containers.list(filters={'name': self.args.app})
            container = containers[0]

        run_mode = self.config['run_mode']
        try:
            opts = self.config['docker_options']
        except:
            opts = {}
        if self.args.detach:
            if self.config['run_mode'] == 'headless':
                opts['detach'] = True
            else:
                print ("Can't detach a non-headless component")
                sys.exit(1)
        opts['environment'] = {}
        opts['mounts'] = []
        extranets = []
        try:
            netname = self.config['networks'][0]
            self.create_network(netname)
            opts['network'] = netname
            extranets = self.config['networks'][1:]
        except KeyError:
            pass
        try:
            ports = {}
            for publish_port in self.config['publish_ports']:
                ports[publish_port] = publish_port
            opts['ports'] = ports
        except KeyError:
            pass
        try:
            image = self.config['image']
        except KeyError:
            image = 'kaboxer/'+self.args.app

        if 'run_as_root' not in self.config:
            self.config['run_as_root'] = False

        if self.config['run_as_root']:
            self.home_in = '/root'
        else:
            import pwd
            uid = os.getuid()
            uname = pwd.getpwuid(os.getuid()).pw_name
            gecos = pwd.getpwuid(os.getuid()).pw_gecos
            gid = pwd.getpwuid(os.getuid()).pw_gid
            gname = grp.getgrgid(gid).gr_name
            self.home_in = os.path.join('/home',uname)

        try:
            for mount in self.config['mounts']:
                s = mount['source']
                s = os.path.expanduser(s)
                try:
                    os.makedirs(s)
                except FileExistsError:
                    pass
                t = mount['target']
                if t == '~':
                    t = self.home_in
                else:
                    t = re.sub('^~/',self.home_in+'/',t)
                opts['mounts'].append(docker.types.Mount(t,s,type='bind'))
        except KeyError:
            pass

        if not self.config['run_as_root'] and not self.args.reuse_container:
            opts2 = opts.copy()
            opts2['detach'] = False
            opts2['tty'] = True
            precmds = [
                [ 'addgroup', '--debug', '--gid', str(gid), gname ],
                [ 'adduser', '--debug', '--uid', str(uid), '--gid', str(gid), '--home', self.home_in, '--gecos', gecos, '--disabled-password', uname ],
            ]
            container = self.docker_conn.containers.create(image, **opts2)
            opts['entrypoint'] = container.attrs['Config']['Entrypoint']
            container.remove()
            try:
                del (opts2['command'])
            except KeyError:
                pass
            for precmd in precmds:
                opts2['entrypoint'] = precmd
                container = self.docker_conn.containers.create(image, **opts2)
                container.start()
                container.wait()
                image = container.commit()
                container.remove()
            opts['user'] = uid
            opts['environment']['HOME'] = self.home_in

        if run_mode == 'cli':
            opts['tty'] = True
            opts['stdin_open'] = True
        elif run_mode == 'gui':
            self.create_xauth()
            opts['environment']['DISPLAY'] = os.getenv('DISPLAY')
            opts['environment']['XAUTHORITY'] = self.xauth_in
            opts['mounts'].append(docker.types.Mount(self.xauth_in,self.xauth_out,type='bind'))
        elif run_mode == 'headless':
            opts['name'] = self.args.app
        else:
            print ("Unknown run mode")
            sys.exit(1)
        if run_mode == 'gui' or ('allow_x11' in self.config and self.config['allow_x11']):
            xsock = '/tmp/.X11-unix'
            opts['mounts'].append(docker.types.Mount(xsock,xsock,type='bind'))
        if 'executable' in self.config:
            executable = self.config['executable']
        else:
            executable = self.args.executable
        if not isinstance(executable,list):
            executable = shlex.split(executable)
        try:
            executable.extend(shlex.split(self.config['extra_opts']))
        except KeyError:
            pass
        try:
            opts['entrypoint'] = ''
        except KeyError:
            pass

        if self.args.reuse_container:
            if run_mode == 'gui':
                self.create_xauth()
                bio = io.BytesIO()
                tf = tarfile.open(mode='w:',fileobj=bio)
                ti = tarfile.TarInfo()
                ti.name = self.xauth_in
                def tifilter(x):
                    if not self.config['run_as_root']:
                        x.uid = uid
                        x.gid = gid
                        x.uname = uname
                        x.gname = gname
                    return x
                tf.add(self.xauth_out, arcname=self.xauth_in, filter=tifilter)
                tf.close()
                container.put_archive('/', bio.getvalue())
            ex_with_env = ['env']
            for e in opts['environment']:
                ex_with_env.append("%s=%s" % (e, shlex.quote(opts['environment'][e])))
            ex_with_env.extend(executable)
            executable = ex_with_env
            dockerpty.exec_command(self.docker_conn.api, container.id, executable)
        else:
            opts['auto_remove'] = True
            container = self.docker_conn.containers.create(image, executable, **opts)
            for e in extranets:
                create_network(e).connect(container)
            dockerpty.start(self.docker_conn.api,container.id)
            if self.args.detach and self.args.prompt_before_detach:
                c = prompt_toolkit.prompt(self.args.prompt_before_detach)

    def stop(self):
        self.read_config()
        run_mode = self.config['run_mode']
        try:
            image = self.config['image']
        except KeyError:
            image = 'kaboxer/'+self.args.app
        if run_mode == 'headless':
            containers = self.docker_conn.containers.list(filters={'name': self.args.app})
            container = containers[0]
            container.stop()
        else:
            print ("Can't stop a non-headless component")
            sys.exit(1)

    def find_config_for_build_app(self):
        try:
            if self.args.path is None:
                path = os.getcwd()
            else:
                path = self.args.path
        except:
            path = os.getcwd()
        yamlfiles = []
        globs = [ 'kaboxer.yaml', '*.kaboxer.yaml' ]
        for g in globs:
            for f in glob.glob(os.path.join(path,g)):
                try:
                    yamlfiles.append(f)
                except:
                    pass
        if self.args.app is None:
            for f in yamlfiles:
                y = yaml.safe_load(open(f))
                try:
                    y['application']['id']
                    parsed_config = y
                    break
                except:
                    pass
        else:
            for f in yamlfiles:
                y = yaml.safe_load(open(f))
                try:
                    if y['application']['id'] == self.args.app:
                        parsed_config = y
                        found_config = f
                        break
                except:
                    pass
        try:
            app = parsed_config['application']['id']
        except:
            print("Failed to find appropriate kaboxer.yaml file")
            sys.exit(1)
        return parsed_config

    def build(self):
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        parsed_config = self.find_config_for_build_app()
        app = parsed_config['application']['id']
        try:
            df = os.path.join(path,parsed_config['build']['docker']['file'])
        except:
            df = os.path.join(path,'Dockerfile')
        (image, _) = self.docker_conn.images.build(path=path, tag='kaboxer/'+app+':latest', dockerfile=df, rm=True, forcerm=True)
        if self.save:
            if self.args.tarball is not None:
                tarball = self.args.tarball
            else:
                tarball = os.path.join(path,parsed_config['application']['id']+'.tar')
            self.save_image_to_file(image,tarball)
        try:
            parsed_config['install']['desktop-files']
        except:
            self._gen_desktop_files()

    def _gen_desktop_files(self):
        parsed_config = self.find_config_for_build_app()
        template_text = """[Desktop Entry]
Name={{ p.name }}
Comment={{ p.comment }}
Exec={{ p.exec }}
Icon=kaboxer-{{ p.appid }}
Terminal={{ p.terminal }}
Type=Application
Categories={{ p.categories }}

"""
        t = jinja2.Template(template_text)
        for component in parsed_config['components']:
            params = {
                'comment': parsed_config['application']['description'],
                'component': component,
                'appid': parsed_config['application']['id'],
                'categories': parsed_config['application']['categories'],
            }
            params['reuse_container'] = ''
            try:
                if parsed_config['components'][component]['reuse_container']:
                    params['reuse_container'] = '--reuse-container '
            except:
                pass
            try:
                component_name = parsed_config['components'][component]['name']
            except:
                component_name = parsed_config['application']['name']
            if parsed_config['components'][component]['run_mode'] == 'headless':
                # One .desktop file for starting
                params['name'] = "Start %s" % (component_name,)
                params['terminal'] = 'true'
                try:
                    detach_message = parsed_config['components'][component]['start_message']
                except:
                    detach_message = "%s started" % (component_name,)
                params['exec'] = "kaboxer run --detach --prompt_before_detach %s%s--component %s %s" % (shlex.quote(detach_message), params['reuse_container'], params['component'], params['appid'])
                ofname = 'kaboxer-%s-%s-start.desktop' % (parsed_config['application']['id'], component)
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))
                # One .desktop file for stopping
                params['name'] = "Stop %s" % (component_name,)
                params['terminal'] = 'false'
                params['exec'] = "kaboxer stop %s--component %s %s" % (params['reuse_container'], params['component'], params['appid'])
                ofname = 'kaboxer-%s-%s-stop.desktop' % (parsed_config['application']['id'], component)
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))
            else:
                params['name'] = component_name
                ofname = 'kaboxer-%s-%s.desktop' % (parsed_config['application']['id'], component)
                params['exec'] = "kaboxer run %s--component %s %s" % (params['reuse_container'], params['component'], params['appid'])
                if parsed_config['components'][component]['run_mode'] == 'cli':
                    params['terminal'] = 'true'
                else:
                    params['terminal'] = 'false'
                with open(ofname, 'w') as outfile:
                    outfile.write(t.render(p=params))

    def clean(self):
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        path = os.path.realpath(path)
        parsed_config = self.find_config_for_build_app()
        app = parsed_config['application']['id']
        if self.args.tarball is not None:
            tarball = self.args.tarball
        else:
            tarball = os.path.join(path,parsed_config['application']['id']+'.tar')
        if os.path.commonpath([path,tarball]) == path and os.path.isfile(tarball):
            os.unlink(tarball)

    def install(self):
        parsed_config = self.find_config_for_build_app()
        if self.args.path is None:
            path = os.getcwd()
        else:
            path = self.args.path
        app = parsed_config['application']['id']
        # Install image tarball
        if self.args.tarball is not None:
            tarball = self.args.tarball
        else:
            tarball = os.path.join(path,app+'.tar')
        destpath = os.path.join(self.args.prefix, 'share/kaboxer')
        if self.args.destdir == '':
            builddestpath = destpath
        else:
            builddestpath = os.path.join(self.args.destdir, os.path.relpath(destpath,'/'))
        os.makedirs(builddestpath, exist_ok=True)
        try:
            shutil.copy(tarball,builddestpath)
        except shutil.SameFileError:
            pass
        # Update and install real kaboxer.yaml file
        try:
            del(parsed_config['container']['origin']['registry'])
        except:
            pass
        if 'origin' not in parsed_config['container']:
            parsed_config['container']['origin'] = {}
        parsed_config['container']['origin']['tarball'] = os.path.join(destpath,app+'.tar')
        with open(os.path.join(builddestpath,app+'.yaml'),'w') as y:
            y.write(yaml.dump(parsed_config))
        # Install desktop file(s)
        destpath = os.path.join(self.args.prefix, 'share/applications')
        if self.args.destdir == '':
            builddestpath = destpath
        else:
            builddestpath = os.path.join(self.args.destdir, os.path.relpath(destpath,'/'))
        os.makedirs(builddestpath, exist_ok=True)
        try:
            desktopfiles = parsed_config['install']['desktop-files']
        except:
            desktopfiles = []
            for component in parsed_config['components']:
                if parsed_config['components'][component]['run_mode'] == 'headless':
                    desktopfiles.append('kaboxer-%s-%s-start.desktop' % (parsed_config['application']['id'], component))
                    desktopfiles.append('kaboxer-%s-%s-stop.desktop' % (parsed_config['application']['id'], component))
                else:
                    desktopfiles.append('kaboxer-%s-%s.desktop' % (parsed_config['application']['id'], component))
        for d in desktopfiles:
            shutil.copy(d,builddestpath)

    def save(self):
        images = self.docker_conn.images.list()
        for image in images:
            for tag in image.tags:
                if tag == 'kaboxer/'+self.args.app + ':latest':
                    self.save_image_to_file(image,self.args.file)
                    return
        print("No image found")
        sys.exit(1)

    def save_image_to_file(self,image,destfile):
        with open(destfile, 'wb') as f:
            for chunk in image.save():
                f.write(chunk)

    def load(self):
        f = open(self.args.file, 'rb')
        for image in self.docker_conn.images.load(f):
            image.tag('kaboxer/'+self.args.app, tag='latest')

    def pull(self):
        self.build()

    def purge(self):
        self.docker_conn.images.remove('kaboxer/'+self.args.app)

    def load_config(self):
        paths = [
            '.',
            '/etc/kaboxer',
            '/usr/local/share/kaboxer',
            '/usr/share/kaboxer',
        ]
        for p in paths:
            config_file = os.path.join(p,self.args.app+'.yaml')
            if os.path.isfile(config_file):
                try:
                    return yaml.safe_load(open(config_file))
                except:
                    print("Error loading config file "+config_file)
                    sys.exit(1)
        print("Missing config file")
        sys.exit(1)

    def read_config(self):
        confs = self.load_config()
        # If a component was specified
        try:
            component = self.args.component
            self.config = confs['components'][component]
            return
        except:
            pass
        # If a default component is listed in the config file
        try:
            component = confs['container']['default_component']
            self.config = confs['components'][component]
            return
        except:
            pass
        # If there is a component called "default"
        try:
            self.config = confs['components']['default']
            return
        except:
            pass
        # Otherwise take the first component
        try:
            components = sorted(confs['components'].keys())
            component = components[0]
            self.config = confs['components'][component]
            return
        except:
            pass
        print("Can't find an appropriate component")
        sys.exit(1)

    def create_network(self, netname):
        for n in self.docker_conn.networks.list():
            if n.name == netname:
                return n
        return self.docker_conn.networks.create(name=netname, driver='bridge')

    def create_xauth(self):
        if os.getenv('DISPLAY') is None:
            print("No DISPLAY set, are you running in a graphical session?")
            sys.exit(1)
        self.xauth_out = os.path.join(os.getenv('HOME'), '.docker.xauth')
        self.xauth_in = os.path.join(self.home_in,'.docker.xauth')
        f = subprocess.Popen(['xauth', 'nlist', os.getenv('DISPLAY')], stdout=subprocess.PIPE).stdout
        g = subprocess.Popen(['xauth', '-f', self.xauth_out, 'nmerge', '-'], stdin=subprocess.PIPE).stdin
        for l in f:
            l = str(l,'utf-8')
            l.strip()
            ll = re.sub('^[^ ]*', 'ffff', l) + "\n"
            g.write(bytes(ll, 'utf-8'))
        g.close()
        f.close()

kaboxer = Kaboxer()
kaboxer.go()
